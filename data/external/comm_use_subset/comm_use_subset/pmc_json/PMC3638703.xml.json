{
    "paper_id": "PMC3638703",
    "metadata": {
        "title": "Structural Complexity of DNA Sequence",
        "authors": [
            {
                "first": "Cheng-Yuan",
                "middle": [],
                "last": "Liou",
                "suffix": "",
                "email": null,
                "affiliation": {}
            },
            {
                "first": "Shen-Han",
                "middle": [],
                "last": "Tseng",
                "suffix": "",
                "email": null,
                "affiliation": {}
            },
            {
                "first": "Wei-Chen",
                "middle": [],
                "last": "Cheng",
                "suffix": "",
                "email": null,
                "affiliation": {}
            },
            {
                "first": "Huai-Ying",
                "middle": [],
                "last": "Tsai",
                "suffix": "",
                "email": null,
                "affiliation": {}
            }
        ]
    },
    "body_text": [
        {
            "text": "DNA sequence analysis becomes important part in modern molecular biology. DNA sequence is composed of four nucleotide bases\u2014adenine (abbreviated A), cytosine (C), guanine (G), and thymine (T) in any order. With four different nucleotides, 2 nucleotides could only code for maximum of 42 amino acids, but 3 nucleotides could code for a maximum 43 amino acids. George Gamow was the first person to postulate that every three bases can translate to a single amino acid, called a codon. Marshall Nirenberg and Heinrich J. Matthaei were the first to elucidate the nature of a genetic code. A short DNA sequence can contain less genetic information, while lots of bases may contain much more genetic information, and any two nucleotides switch place may change the meaning of genetic messages.",
            "cite_spans": [],
            "section": "1. Introduction ",
            "ref_spans": []
        },
        {
            "text": "Sequence arrangement can produce many different results, but only few codons exist in living bodies. Some sequences do not contain any information which is known as junk DNA. Finding an efficient way to analyze a sequence fragment corresponding to genetic functions is also a challenging problem.",
            "cite_spans": [],
            "section": "1. Introduction ",
            "ref_spans": []
        },
        {
            "text": "In recent papers, methods broadly fall into two categories, sequence complexity [1, 2] and structural pattern analysis [3\u20138]. Koslicki [1] presented a method for computing sequence complexities. He redefined topological entropy function so that the complexity value will not converge toward zero for much longer sequences. With separate sequence into several segments, it can determine the segments where are exons or introns, and meaningful or meaningless. Hao et al. [7] given a graphical representation of DNA sequence, according to this paper, we can find some rare occurred subsequences. R. Zhang and C. T. Zhang [4] used four-nucleotide-related function drawing 3D curves graph to analyze the number of four-nucleotide occurrence probabilities. Liou et al. [9] had given a new idea in modeling complexity for music rhythms; this paper translated text messages into computable values, so computers can score for music rhythms.",
            "cite_spans": [
                {
                    "start": 81,
                    "end": 82,
                    "mention": "1",
                    "ref_id": "BIBREF10"
                },
                {
                    "start": 84,
                    "end": 85,
                    "mention": "2",
                    "ref_id": "BIBREF11"
                },
                {
                    "start": 120,
                    "end": 121,
                    "mention": "3",
                    "ref_id": "BIBREF12"
                },
                {
                    "start": 122,
                    "end": 123,
                    "mention": "8",
                    "ref_id": "BIBREF17"
                },
                {
                    "start": 136,
                    "end": 137,
                    "mention": "1",
                    "ref_id": "BIBREF10"
                },
                {
                    "start": 470,
                    "end": 471,
                    "mention": "7",
                    "ref_id": "BIBREF16"
                },
                {
                    "start": 619,
                    "end": 620,
                    "mention": "4",
                    "ref_id": "BIBREF13"
                },
                {
                    "start": 764,
                    "end": 765,
                    "mention": "9",
                    "ref_id": "BIBREF0"
                }
            ],
            "section": "1. Introduction ",
            "ref_spans": []
        },
        {
            "text": "In this paper, we propose a new method for calculating sequences different from other traditional methods. It holds not only statistical values but also structural information. We replace four nucleotides with tree structure presented in [9] and use mathematical tools to calculate complexity values of the sequences. So we can compare two sequences with values and determine dissimilarity between these two sequences. In biomedical section, we can use this technique to find the effective drugs for new virus with priority.",
            "cite_spans": [
                {
                    "start": 239,
                    "end": 240,
                    "mention": "9",
                    "ref_id": "BIBREF0"
                }
            ],
            "section": "1. Introduction ",
            "ref_spans": []
        },
        {
            "text": "For computing complexity of our DNA tree, we need some rules for converting tree to another structure. We use a stack similarly structure to represent the hierarchy of DNA tree, called bracketed string. DNA tree can transfer to a unique bracketed string by the following symbols, and it can transfer back to the original tree:\nF: the current location of tree nodes; it can be replaced by any word or be omitted;+: the following string will express the right subtree;\u2212: the following string will express the left subtree;[: this symbol is pairing with ]; \u201c[\u22ef]\u201d denotes a subtree where \u201c\u22ef\u201d; indicates all the bracketed strings of its subtree;]: see [ description. \n",
            "cite_spans": [],
            "section": "2.1. Bracketed Strings for a DNA Sequence ::: 2. DNA Sequence Represented with Tree Structure",
            "ref_spans": []
        },
        {
            "text": "Following the previous symbols, Figure 3 shows that nucleotide base A and T represented tree can transfer to [F[\u2212F][+F]] and [F[\u2212F][+F[\u2212F][+F]]], respectively.",
            "cite_spans": [],
            "section": "2.1. Bracketed Strings for a DNA Sequence ::: 2. DNA Sequence Represented with Tree Structure",
            "ref_spans": [
                {
                    "start": 32,
                    "end": 40,
                    "mention": "Figure 3",
                    "ref_id": "FIGREF7"
                }
            ]
        },
        {
            "text": "And Figure 4 is the bracketed string of Figure 2. We can see that when the tree grows, string seems to be more redundant. Since we focus here only on DNA trees, we can simplify the bracketed string representations. First, our trees have only two subtrees. Second, the \u201cF\u201d notation for the tree is trivial. With these two characteristics, we may omit the \u201cF\u201d notation from the bracketed string and use only four symbols, {[, ], \u2212, +}, to represent trees. In our cases, \u201c[\u22ef]\u201d denotes a subtree where \u201c\u22ef\u201d indicates all the bracketed strings of its subtrees. \u201c\u2212\u201d indicated the next \u201c[\u22ef]\u201d notation for a tree is a left subtree of current node, and \u201c+\u201d is a right subtree vice versa.  Figure 5 is the simplified string of bracketed string shown in Figure 4.",
            "cite_spans": [],
            "section": "2.1. Bracketed Strings for a DNA Sequence ::: 2. DNA Sequence Represented with Tree Structure",
            "ref_spans": [
                {
                    "start": 4,
                    "end": 12,
                    "mention": "Figure 4",
                    "ref_id": "FIGREF8"
                },
                {
                    "start": 40,
                    "end": 48,
                    "mention": "Figure 2",
                    "ref_id": "FIGREF6"
                },
                {
                    "start": 678,
                    "end": 687,
                    "mention": " Figure 5",
                    "ref_id": "FIGREF9"
                },
                {
                    "start": 742,
                    "end": 750,
                    "mention": "Figure 4",
                    "ref_id": "FIGREF8"
                }
            ]
        },
        {
            "text": "When we obtain DNA tree and bracketed string representation, we need rewriting rules for analyzing tree structure. There are some types of rewriting mechanism such as Chomsky grammar and Lindenmayer system (L-system for short). The largest difference between two string rewriting mechanisms lies in the technique used to apply productions. Chomsky grammar is suitable for applying productions sequentially, while L-system is for parallel. In our structure, applying L-system to our representations is better than Chomsky grammar.",
            "cite_spans": [],
            "section": "2.2. DNA Sequence Represented with L-System ::: 2. DNA Sequence Represented with Tree Structure",
            "ref_spans": []
        },
        {
            "text": "The L-system was introduced by the biologist Lindenmayer in 1968 [13]. The central concept of the L-system is rewriting. In general, rewriting is a technique used to define complex objects by successively replacing parts of a simple initial object, using a set of rewriting rules or productions. In the next section, we will present how we use L-system to our DNA tree. The L-system is defined as follows.",
            "cite_spans": [
                {
                    "start": 66,
                    "end": 68,
                    "mention": "13",
                    "ref_id": "BIBREF4"
                }
            ],
            "section": "2.2. DNA Sequence Represented with L-System ::: 2. DNA Sequence Represented with Tree Structure",
            "ref_spans": []
        },
        {
            "text": "\nDefinition 1L-system grammars are very similar to the Chomsky grammar, defined as a tuple [14]:\n(1)G=(V,\u03c9,P),\nwhere\nV = {s\n1, s\n2,\u2026, s\nn} is an alphabet,\n\u03c9 (start, axiom, or initiator) is a string of symbols from V defining the initial state of the system,\nP is defined by a production map P : V \u2192 V* with s \u2192 P(s) for each s in V. The identity production s \u2192 s is assumed. These symbols are called constants or terminals. \n\n",
            "cite_spans": [
                {
                    "start": 92,
                    "end": 94,
                    "mention": "14",
                    "ref_id": "BIBREF5"
                }
            ],
            "section": "2.2. DNA Sequence Represented with L-System ::: 2. DNA Sequence Represented with Tree Structure",
            "ref_spans": []
        },
        {
            "text": "As discussed earlier, we want to generate the rules from DNA trees. In this section, we will explain how we apply rewriting rules to those trees. We can apply distinct variables to each node. Since the technique described previously always generates two subtrees for each node, for every nonterminal node, they always can be explained in the following format:\n(2)P\u2192LR,\nwhere P denotes the current node, L denotes its left subtree, and R denotes its right subtree, respectively. We give an example shown in Figure 6; left tree has three nodes and only root is nonterminal node, it can be rewritten as P \u2192 LR. Right tree has five nodes, root P with left subtree L and right subtree R. Left subtree is terminal, but right is not. R has two terminal subtrees R\nL and R\nR, so this tree can be rewritten as P \u2192 LR and R \u2192 R\nL\nR\nR.",
            "cite_spans": [],
            "section": "2.3. Rewriting Rules for DNA Sequences ::: 2. DNA Sequence Represented with Tree Structure",
            "ref_spans": [
                {
                    "start": 506,
                    "end": 514,
                    "mention": "Figure 6",
                    "ref_id": "FIGREF10"
                }
            ]
        },
        {
            "text": "Similarly, we can also use rewriting rules to generate bracketed strings. In rewriting rules for DNA trees shown in Section 2.3, we write P \u2192 LR for a tree with left and right subtrees. Note that we call L and R as the nonterminals. In this section, terminal nodes will be separated from trees, and we use \u201cnull\u201d to represent a terminal. Such tree will have a corresponding bracketed string as follows: [[\u2212F\u22ef][+F\u22ef]]. \u201c[\u2212F\u22ef]\u201d represents the left subtree, while \u201c[+F\u22ef]\u201d represents the right subtree. Therefore, we can replace the rewriting rules with\n(3)P\u2192[\u2212FL][+FR],F\u2192\u22ef,R\u2192\u22ef,\nwhere \u201c\u22ef\u201d is the rewriting rule for the bracketed string of each subtree. For the sake of readability, we replace the words such as \u201cR\nRL\u201d and \u201cR\nRR\u201d. In Figure 7, we show the rewriting rules for the bracketed string of the tree in Figure 3.",
            "cite_spans": [],
            "section": "2.4. Rewriting Rules for Bracketed Strings ::: 2. DNA Sequence Represented with Tree Structure",
            "ref_spans": [
                {
                    "start": 728,
                    "end": 736,
                    "mention": "Figure 7",
                    "ref_id": "FIGREF11"
                },
                {
                    "start": 806,
                    "end": 814,
                    "mention": "Figure 3",
                    "ref_id": "FIGREF7"
                }
            ]
        },
        {
            "text": "As we can see, there are \u201cnulls\" in the rules. Those \u201cnulls\u201d do not have significant effects to our algorithm, so we simply ignore the nulls. Now, Figure 3 can apply new rewriting rules without trivial nulls as Figure 8.",
            "cite_spans": [],
            "section": "2.4. Rewriting Rules for Bracketed Strings ::: 2. DNA Sequence Represented with Tree Structure",
            "ref_spans": [
                {
                    "start": 147,
                    "end": 155,
                    "mention": "Figure 3",
                    "ref_id": "FIGREF7"
                },
                {
                    "start": 211,
                    "end": 219,
                    "mention": "Figure 8",
                    "ref_id": "FIGREF12"
                }
            ]
        },
        {
            "text": "When tree grows up, the rewriting rules may generate identical rules. Assume that we have the following rules:\n(4)P\u2192[\u2212FTL][+FTR],TL\u2192[\u2212F][+F],TR\u2192[\u2212F][+FTRR],TRR\u2192[\u2212F][+FTRRR],TRRR\u2192[\u2212F].\nThese rules can generate exactly one bracketed string and, thus, exactly one DNA tree. All these rules form a rule set that represents a unique DNA tree. When we look at T\nR \u2192 [\u2212F][+FT\nRR] and T\nRR \u2192 [\u2212F][+FT\nRRR], they have the same structure since they both have a right subtree and do not have a left subtree. The only difference is that one of the subtrees is T\nRR and that the other is T\nRRR. We will define two terms to express the similarity between two rewriting rules, and these terms can simplify complexity analysis.",
            "cite_spans": [],
            "section": "2.4. Rewriting Rules for Bracketed Strings ::: 2. DNA Sequence Represented with Tree Structure",
            "ref_spans": []
        },
        {
            "text": "At the end of the previous section, we discussed that T\nR \u2192 [\u2212F][+FT\nRR] and T\nRR \u2192 [\u2212F][+FT\nRRR] are almost the same. How can we summarize or organize an effective feature to them? Liou et al. [9] gave two definitions to classify similar rewriting rules described before as follows.",
            "cite_spans": [
                {
                    "start": 195,
                    "end": 196,
                    "mention": "9",
                    "ref_id": "BIBREF0"
                }
            ],
            "section": "2.5. Homomorphism and Isomorphism of Rewriting Rules ::: 2. DNA Sequence Represented with Tree Structure",
            "ref_spans": []
        },
        {
            "text": "\nDefinition 2Homomorphism in rewriting rules. We define that rewriting rule R\n1 and rewriting rule R\n2 are homomorphic to each other if and only if they have the same structure. \n",
            "cite_spans": [],
            "section": "2.5. Homomorphism and Isomorphism of Rewriting Rules ::: 2. DNA Sequence Represented with Tree Structure",
            "ref_spans": []
        },
        {
            "text": "In detail, rewriting rule R\n1 and rewriting rule R\n2 in DNA trees both have subtrees in corresponding positions or both not. Ignoring all nonterminals, if rule R\n1 and rule R\n2 generate the same bracketed string, then they are homomorphic by definition.",
            "cite_spans": [],
            "section": "2.5. Homomorphism and Isomorphism of Rewriting Rules ::: 2. DNA Sequence Represented with Tree Structure",
            "ref_spans": []
        },
        {
            "text": "\nDefinition 3Isomorphism on level X in rewriting rules. Rewriting rule R\n1 and rewriting rule R\n2 are isomorphic on depth X if they are homomorphic and their nonterminals are relatively isomorphic on depth X \u2212 1. Isomorphic on level 0 indicates homomorphism. \n",
            "cite_spans": [],
            "section": "2.5. Homomorphism and Isomorphism of Rewriting Rules ::: 2. DNA Sequence Represented with Tree Structure",
            "ref_spans": []
        },
        {
            "text": "Applying to the bracketed string, we ignore all nonterminals in (4) as follows:\n(5)P\u2192[\u2212FTL][+FTR]\u2192[\u2212F][+F],TL\u2192[\u2212F][+F]\u2192[\u2212F][+F],TR\u2192[\u2212F][+FTRR]\u2192[\u2212F][+F],TRR\u2192[\u2212F][+FTRRR]\u2192[\u2212F][+F],TRRR\u2192[\u2212F]\u2192[\u2212F].\n",
            "cite_spans": [],
            "section": "2.5. Homomorphism and Isomorphism of Rewriting Rules ::: 2. DNA Sequence Represented with Tree Structure",
            "ref_spans": []
        },
        {
            "text": "We find that P, T\nL, T\nR, and T\nRR are homomorphic to each other; they generate the same bracketed string, [\u2212F][+F]. But T\nRRR is not homomorphic to any of the other rules; its bracketed string is [\u2212F].",
            "cite_spans": [],
            "section": "2.5. Homomorphism and Isomorphism of Rewriting Rules ::: 2. DNA Sequence Represented with Tree Structure",
            "ref_spans": []
        },
        {
            "text": "Let us recall DNA tree example in Figure 2; we will use this figure as an example to clarify these definitions. Now we marked some nodes shown in Figure 9; there are tree rooted at A, B, C, and D, respectively, tree A, tree B, tree C, and tree D. Tree A is isomorphic to tree C on depth 0 to 3, but they are not isomorphic on depth 4. Tree B is isomorphic to tree C on depth from 0 to 2, but they are not isomorphic on depth 3. D is not isomorphic to any other trees, nor is it homomorphic to any other trees.",
            "cite_spans": [],
            "section": "2.5. Homomorphism and Isomorphism of Rewriting Rules ::: 2. DNA Sequence Represented with Tree Structure",
            "ref_spans": [
                {
                    "start": 34,
                    "end": 42,
                    "mention": "Figure 2",
                    "ref_id": "FIGREF6"
                },
                {
                    "start": 146,
                    "end": 154,
                    "mention": "Figure 9",
                    "ref_id": "FIGREF13"
                }
            ]
        },
        {
            "text": "After we define the similarity between rules by homomorphism and isomorphism, we can classify all the rules into different subsets, and every subset has the same similarity relation. Now we list all the rewriting rules of Figure 2 into Table 1 but ignore terminal rules such as \u201c\u2192 null\u201d and transfer rule's name to class name (or class number). For example, we can give terminal rewriting rule a class, \u201cC\n3\u2192 null\u201d, and a rule link to two terminals; we can give them \u201cC\n2 \u2192 C\n3\nC\n3\"; here C\n3 is the terminal class. After performing classification, we obtain not only a new rewriting rule set but also a context-free grammar, which can be converted to automata.",
            "cite_spans": [],
            "section": "2.5. Homomorphism and Isomorphism of Rewriting Rules ::: 2. DNA Sequence Represented with Tree Structure",
            "ref_spans": [
                {
                    "start": 222,
                    "end": 230,
                    "mention": "Figure 2",
                    "ref_id": "FIGREF6"
                },
                {
                    "start": 236,
                    "end": 243,
                    "mention": "Table 1",
                    "ref_id": "TABREF0"
                }
            ]
        },
        {
            "text": "In Table 1, rules such as T\nRLLL \u2192 [\u2212F][+F], and T\nRRRLL \u2192 [\u2212F][+F] and T\nRLRLR \u2192 [\u2212F][+F] are isomorphic on depth 1 and assigned to Class 4. There are twenty such rules before classification, so we write \u201c(20)C\n4 \u2192 [\u2212F][+F]\u201d. Similar rules such as P \u2192 [\u2212FT\nL][+FT\nR], T\nRLLL \u2192 [\u2212F][+F], and T\nRRRR \u2192 [\u2212F][+FT\nRRRRR] are isomorphic on depth 0, and there are 47 such rules. They are all assigned to Class 1 by following a similar classification procedure. The classification of the all rules is listed in Table 2. Note that this section also presents a new way to convert a context-sensitive grammar to a context-free one.",
            "cite_spans": [],
            "section": "2.5. Homomorphism and Isomorphism of Rewriting Rules ::: 2. DNA Sequence Represented with Tree Structure",
            "ref_spans": [
                {
                    "start": 3,
                    "end": 10,
                    "mention": "Table 1",
                    "ref_id": "TABREF0"
                },
                {
                    "start": 504,
                    "end": 511,
                    "mention": "Table 2",
                    "ref_id": "TABREF1"
                }
            ]
        },
        {
            "text": "When we transfer the DNA sequence to the rewriting rules, and classify all those rules we attempt to explore the redundancy in the tree that will be the base for building the cognitive map [15]. We compute the complexity of the tree which those classified rules represent. We know that a classified rewriting rule set is also a context-free grammar, so there are some methods for computing complexity of rewriting rule as follows.",
            "cite_spans": [
                {
                    "start": 190,
                    "end": 192,
                    "mention": "15",
                    "ref_id": "BIBREF6"
                }
            ],
            "section": "3. DNA Sequence Complexity",
            "ref_spans": []
        },
        {
            "text": "\nDefinition 4Topological entropy of a context-free grammar. The topological entropy K\n0 of (context-free grammar) CFG can be evaluated by means of the following three procedures [16, 17].(1)For each variable V\ni with productions (in Greibach form),\n(6)Vi\u2192ti1Ui1,ti2Ui2,\u2026,tikiUiki,\nwhere {t\ni1, t\ni2,\u2026, t\niki} are terminals and {U\ni1, U\ni2,\u2026, U\niki} are nonterminals. The formal algebraic expression for each variable is\n(7)Vi=\u2211j=1kitijUij.\n(2)By replacing every terminal t\nij with an auxiliary variable z, one obtains the generating function\n(8)Vi(z)=\u2211n=1\u221eNi(n)zn,\nwhere N\ni(n) is the number of words of length n descending from V\ni.(3)Let N(n) be the largest one of N\ni(n), N(n) = max\u2061{N\ni(n), for all i}. The previous series converges when z < R = e\n\u2212K0. The topological entropy is given by the radius of convergence R as\n(9)K0=\u2212ln\u2061R.\n\n\n",
            "cite_spans": [
                {
                    "start": 179,
                    "end": 181,
                    "mention": "16",
                    "ref_id": "BIBREF7"
                },
                {
                    "start": 183,
                    "end": 185,
                    "mention": "17",
                    "ref_id": "BIBREF8"
                }
            ],
            "section": "3. DNA Sequence Complexity",
            "ref_spans": []
        },
        {
            "text": "Our productions have some difference from the aforementioned definitions. First, our productions are written in Chomsky-reduced form instead of Greibach form. Second, DNA is finite sequence; it generates finite tree, but the previous formulas are applied on infinite sequences. For convenience in the DNA tree case, we rewrite the definition as follows [9].",
            "cite_spans": [
                {
                    "start": 354,
                    "end": 355,
                    "mention": "9",
                    "ref_id": "BIBREF0"
                }
            ],
            "section": "3. DNA Sequence Complexity",
            "ref_spans": []
        },
        {
            "text": "\nDefinition 5Topological entropy of context free grammar for DNA tree.(1)Assume that there are n classes of rules and that each class C\ni contains n\ni rules. Let V\ni \u2208 {C\n1, C\n2,\u2026, C\nn}, U\nij \u2208 {R\nij, i = 1,2,\u2026, n, j = 1,2,\u2026, n\ni}, and a\nijk \u2208 {x : x = 1,2,\u2026, n}, where each U\nij has the following form:\n(10)Ui1\u2192Vai11Vai12,Ui2\u2192Vai21Vai22,\u22ef\u2192\u22ef,Uini\u2192Vaini1Vaini2.\n(2)The generating function of V\ni, V\ni(z) has a new form as follows:\n(11)Vi(z)=\u2211p=1ninipzVaip1(z)Vaip2(z)\u2211q=1niniq.\nIf V\ni does not have any nonterminal variables, we set V\ni(z) = 1.(3)After formulating the generating function V\ni(z), we intend to find the largest value of z, z\nmax\u2061, at which V\n1(z\nmax\u2061) converges. Note that we use V\n1 to denote the rule for the root node of the DNA tree. After obtaining the largest value, z\nmax\u2061, of V\n1(z), we set R = z\nmax\u2061, the radius of convergence of V\n1(z). We define the complexity of the DNA tree as\n(12)K0=\u2212ln\u2061R.\n\n\n",
            "cite_spans": [],
            "section": "3. DNA Sequence Complexity",
            "ref_spans": []
        },
        {
            "text": "Now we can do some examples of computation procedure for the complexity. According to our definition, the given values for the class parameters are listed in Table 3. There are five classes, so we obtain the formulas for V\n5(z\u2032), V\n4(z\u2032), V\n3(z\u2032), V\n2(z\u2032), and V\n1(z\u2032) successively. They are\n(13)V5(z\u2032)=1(by definition),V4(z\u2032)=\u2211p=1n4n4pz\u2032Va4p1(z\u2032)Va4p2(z\u2032)\u2211q=1niniq   =z\u2032\u00d7(20\u00d7V5(z\u2032)\u00d7V5(z\u2032))20=z\u2032,V3(z\u2032)=\u2211p=1n3n3pz\u2032Va3p1(z\u2032)Va3p2(z\u2032)\u2211q=1niniq   =z\u2032\u00d7(4\u00d7V5(z\u2032)\u00d7V4(z\u2032))4=z\u20322,V2(z\u2032)=\u2211p=1n2n2pz\u2032Va2p1(z\u2032)Va2p2(z\u2032)\u2211q=1niniq   =z\u2032\u00d7(4\u00d7V4(z\u2032)\u00d7V5(z\u2032))4=z\u20322,V1(z\u2032)=\u2211p=1n1n1pz\u2032Va1p1(z\u2032)Va1p2(z\u2032)\u2211q=1niniq   =8z\u2032\u00d7V1(z\u2032)2+2(z\u2032)3\u00d7V1(z\u2032)19    +(2(z\u2032)5+2(z\u2032)4+5(z\u2032)3)19.\n",
            "cite_spans": [],
            "section": "3. DNA Sequence Complexity",
            "ref_spans": [
                {
                    "start": 158,
                    "end": 165,
                    "mention": "Table 3",
                    "ref_id": "TABREF2"
                }
            ]
        },
        {
            "text": "Rearranging the previous equation for V\n1(z\u2032), we obtain a quadratic for V\n1(z\u2032):\n(14)819(z\u2032)\u00d7V1(z\u2032)+(1\u2212219(z\u2032)3)\u00d7V1(z\u2032)  +119(2(z\u2032)5+2(z\u2032)4+5(z\u2032)3)=0.\n",
            "cite_spans": [],
            "section": "3. DNA Sequence Complexity",
            "ref_spans": []
        },
        {
            "text": "Solving V\n1(z\u2032), we obtain the formula\n(15)V1(z\u2032)=((z\u2032)24\u2212198z\u2032)\u00b1198z\u2032B2\u2212A,\nwhere\n(16)A=32361(2(z\u2032)6+2(z\u2032)5+5(z\u2032)4),B=1\u2212219(z\u2032)3.\n",
            "cite_spans": [],
            "section": "3. DNA Sequence Complexity",
            "ref_spans": []
        },
        {
            "text": "Finally, the radius of convergence, R, and complexity, K\n0 = \u2212ln\u2061R, can be obtained from this formula. But, computing the z\nmax\u2061 directly is difficult, so we use iterations and region tests to approximate the complexity; details are as follows.(1)Rewrite the generating function as\n(17)Vim(z\u2032)=\u2211p=1ninipz\u2032Vaip1m\u22121(z\u2032)Vaip2m\u22121(z\u2032)\u2211q=1niniq,Vi0(z\u2032)=1.\n(2)The value from V\ni\n0(z\u2032) to V\ni\nm(z\u2032). When V\ni\nm\u22121(z\u2032) = V\ni\nm(z\u2032) for all rules, we say that V\ni\nm(z\u2032) reach the convergence, but z\u2032 is not the z\nmax\u2061 we want. Here, we set m = 1000 for each iteration.(3)Now we can test whether V\ni(z\u2032) is convergent or divergent at a number z\u2032. We use binary search to test every real number between 0 and 1; in every test, when V\ni(z\u2032) converges, we set bigger z\u2032 next time, but when V\ni(z\u2032) diverges, we set smaller z\u2032 next time. Running more iterations will obtain more precise radius. \n",
            "cite_spans": [],
            "section": "3. DNA Sequence Complexity",
            "ref_spans": []
        },
        {
            "text": "Now we can apply our technique to Chinese word sequences. Togawa et al. [18] gave a complexity of Chinese words, but his study was based on the number of strokes, which is different from our method. Here we use Big5 encoding for our system. Since the number of Chinese words is larger than 10000, we cannot directly use words as alphabet, so we need some conversion. We read a Chinese word into four hexadecimal letters so that we can replace the sequence with tree representation and compute the complexity.",
            "cite_spans": [
                {
                    "start": 73,
                    "end": 75,
                    "mention": "18",
                    "ref_id": "BIBREF9"
                }
            ],
            "section": "4.1. Application to Virus Sequences Database and Other Sequences ::: 4. Results",
            "ref_spans": []
        },
        {
            "text": "When it comes to biomedical section, we can create virus comparison database. Once a new virus or prion has been found, it will be easy to select corresponding drugs at the first time, according to cross comparison with each other by complexity in the database. We focus on most important viruses in recent years, such as Escherichia coli O157:H7 (E. coli o157), Enterovirus 71 (EV71), Influenza A virus subtype H1N1 (H1N1), Influenza A virus subtype H5N1 (H5N1), and severe acute respiratory syndrome (SARS). In recent years, these viruses have a significant impact and threat on the human world. We test these viruses and prions listed in Table 4. Here we can see that all prion regions cannot be analyzed by Koslicki method, but we can do it.",
            "cite_spans": [],
            "section": "4.1. Application to Virus Sequences Database and Other Sequences ::: 4. Results",
            "ref_spans": [
                {
                    "start": 641,
                    "end": 648,
                    "mention": "Table 4",
                    "ref_id": "TABREF3"
                }
            ]
        },
        {
            "text": "Finally, if any object can be written as a sequence, and there exists tree representation with alphabet of sequence, we can compute the complexity of the object.",
            "cite_spans": [],
            "section": "4.1. Application to Virus Sequences Database and Other Sequences ::: 4. Results",
            "ref_spans": []
        },
        {
            "text": "In this paper, we give a method for computing complexity of DNA sequences. The traditional method focused on the statistical data or simply explored the structural complexity without value. In our method, we transform the DNA sequence to DNA tree with tree representations at first.",
            "cite_spans": [],
            "section": "5. Summary",
            "ref_spans": []
        },
        {
            "text": "Then we transform the tree to context-free grammar format, so that it can be classified. Finally, we use redefined generating function and find the complexity values. We give a not only statistical but also structural complexity for DNA sequences, and this technique can be used in many important applications.",
            "cite_spans": [],
            "section": "5. Summary",
            "ref_spans": []
        }
    ],
    "ref_entries": {
        "TABREF0": {
            "text": "Table 1: Rewriting rules for the DNA tree in Figure 2.\n",
            "type": "table"
        },
        "TABREF1": {
            "text": "Table 2: Classification based on the similarity of rewriting rules.\n",
            "type": "table"
        },
        "TABREF2": {
            "text": "Table 3: The values for the class parameters of Table 2.\n",
            "type": "table"
        },
        "TABREF3": {
            "text": "Table 4: Test data with topological entropy method and our method.\n",
            "type": "table"
        },
        "FIGREF0": {
            "text": "Figure 1: Nucleotide bases corresponding trees.",
            "type": "figure"
        },
        "FIGREF1": {
            "text": "Figure 10: Koslicki method (topological entropy method, TE for short) example. ",
            "type": "figure"
        },
        "FIGREF2": {
            "text": "Figure 11: Our method compared with TE using test sequences.",
            "type": "figure"
        },
        "FIGREF3": {
            "text": "Figure 12: An amino acid sequence example, Bovine spongiform encephalopathy.",
            "type": "figure"
        },
        "FIGREF4": {
            "text": "Figure 13: Compare with different methods. ",
            "type": "figure"
        },
        "FIGREF5": {
            "text": "Figure 14: Compare with different fragment sizes. ",
            "type": "figure"
        },
        "FIGREF6": {
            "text": "Figure 2: DNA sequence represented with tree structure.",
            "type": "figure"
        },
        "FIGREF7": {
            "text": "Figure 3: Bracketed strings representation for two trees. ",
            "type": "figure"
        },
        "FIGREF8": {
            "text": "Figure 4: Bracketed strings representation for Figure 2.",
            "type": "figure"
        },
        "FIGREF9": {
            "text": "Figure 5: More simply bracketed strings representation for Figure 2. ",
            "type": "figure"
        },
        "FIGREF10": {
            "text": "Figure 6: Example of rewriting rules for trees.",
            "type": "figure"
        },
        "FIGREF11": {
            "text": "Figure 7: Rewriting rules for the bracketed string of trees. ",
            "type": "figure"
        },
        "FIGREF12": {
            "text": "Figure 8: Rewriting rules for the bracketed string without nulls of trees.",
            "type": "figure"
        },
        "FIGREF13": {
            "text": "Figure 9: Example of homomorphism and isomorphism.",
            "type": "figure"
        }
    },
    "back_matter": [],
    "bib_entries": {
        "BIBREF0": {
            "title": "Modeling complexity in musical rhythm",
            "authors": [
                {
                    "first": "CY",
                    "middle": [],
                    "last": "Liou",
                    "suffix": ""
                },
                {
                    "first": "TH",
                    "middle": [],
                    "last": "Wu",
                    "suffix": ""
                },
                {
                    "first": "CY",
                    "middle": [],
                    "last": "Lee",
                    "suffix": ""
                }
            ],
            "year": 2010,
            "venue": "Complexity",
            "volume": "15",
            "issn": "4",
            "pages": "19-30",
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF1": {
            "title": "Score generation with lsystems",
            "authors": [
                {
                    "first": "P",
                    "middle": [],
                    "last": "Prusinkiewicz",
                    "suffix": ""
                }
            ],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "455-457",
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF2": {
            "title": "",
            "authors": [
                {
                    "first": "P",
                    "middle": [],
                    "last": "Prusinkiewicz",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Lindenmayer",
                    "suffix": ""
                }
            ],
            "year": 1996,
            "venue": "The Algorithmic Beauty of Plants",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF3": {
            "title": "Growing music: musical interpretations of L-systems",
            "authors": [
                {
                    "first": "P",
                    "middle": [],
                    "last": "Worth",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Stepney",
                    "suffix": ""
                }
            ],
            "year": 2005,
            "venue": "Applications of Evolutionary Computing",
            "volume": "3449",
            "issn": "",
            "pages": "545-550",
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF4": {
            "title": "Mathematical models for cellular interactions in development II. Simple and branching filaments with two-sided inputs",
            "authors": [
                {
                    "first": "A",
                    "middle": [],
                    "last": "Lindenmayer",
                    "suffix": ""
                }
            ],
            "year": 1968,
            "venue": "Journal of Theoretical Biology",
            "volume": "18",
            "issn": "3",
            "pages": "300-315",
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF5": {
            "title": "Wikipedia: L-system\u2014Wikipedia, the free encyclopedia",
            "authors": [],
            "year": 2012,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF6": {
            "title": "Unsupervised learning",
            "authors": [
                {
                    "first": "H",
                    "middle": [],
                    "last": "Barlow",
                    "suffix": ""
                }
            ],
            "year": 1989,
            "venue": "Neural Computation",
            "volume": "1",
            "issn": "3",
            "pages": "295-311",
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF7": {
            "title": "",
            "authors": [
                {
                    "first": "R",
                    "middle": [],
                    "last": "Badii",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Politi",
                    "suffix": ""
                }
            ],
            "year": 1999,
            "venue": "Complexity: Hierarchical Structures and Scaling in Physics",
            "volume": "6",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF8": {
            "title": "On the entropy of context-free languages",
            "authors": [
                {
                    "first": "W",
                    "middle": [],
                    "last": "Kuich",
                    "suffix": ""
                }
            ],
            "year": 1970,
            "venue": "Information and Control",
            "volume": "16",
            "issn": "2",
            "pages": "173-200",
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF9": {
            "title": "Complexity of chinese characters",
            "authors": [
                {
                    "first": "T",
                    "middle": [],
                    "last": "Togawa",
                    "suffix": ""
                },
                {
                    "first": "K",
                    "middle": [],
                    "last": "Otsuka",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Hiki",
                    "suffix": ""
                },
                {
                    "first": "H",
                    "middle": [],
                    "last": "Kitaoka",
                    "suffix": ""
                }
            ],
            "year": 2001,
            "venue": "Forma",
            "volume": "15",
            "issn": "",
            "pages": "409-414",
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF10": {
            "title": "Topological entropy of DNA sequences",
            "authors": [
                {
                    "first": "D",
                    "middle": [],
                    "last": "Koslicki",
                    "suffix": ""
                }
            ],
            "year": 2011,
            "venue": "Bioinformatics",
            "volume": "27",
            "issn": "8",
            "pages": "1061-1067",
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF11": {
            "title": "Entropy and multi-fractality for the myeloma multiple tet 2 gene",
            "authors": [
                {
                    "first": "C",
                    "middle": [],
                    "last": "Cattani",
                    "suffix": ""
                },
                {
                    "first": "G",
                    "middle": [],
                    "last": "Pierro",
                    "suffix": ""
                },
                {
                    "first": "G",
                    "middle": [],
                    "last": "Altieri",
                    "suffix": ""
                }
            ],
            "year": 2012,
            "venue": "Mathematical Problems in Engineering",
            "volume": "2012",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF12": {
            "title": "Reverse engineering approach in molecular evolution: simulation and case study with enzyme proteins",
            "authors": [
                {
                    "first": "S",
                    "middle": [],
                    "last": "Manna",
                    "suffix": ""
                },
                {
                    "first": "CY",
                    "middle": [],
                    "last": "Liou",
                    "suffix": ""
                }
            ],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "529-533",
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF13": {
            "title": "Z curves, an intutive tool for visualizing and analyzing the DNA sequences",
            "authors": [
                {
                    "first": "R",
                    "middle": [],
                    "last": "Zhang",
                    "suffix": ""
                },
                {
                    "first": "CT",
                    "middle": [],
                    "last": "Zhang",
                    "suffix": ""
                }
            ],
            "year": 1994,
            "venue": "Journal of Biomolecular Structure and Dynamics",
            "volume": "11",
            "issn": "4",
            "pages": "767-782",
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF14": {
            "title": "Spatial representation of symbolic sequences through iterative function systems",
            "authors": [
                {
                    "first": "P",
                    "middle": [],
                    "last": "Ti\u00f1o",
                    "suffix": ""
                }
            ],
            "year": 1999,
            "venue": "IEEE Transactions on Systems, Man, and Cybernetics A",
            "volume": "29",
            "issn": "4",
            "pages": "386-393",
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF15": {
            "title": "Long-range correlations in nucleotide sequences",
            "authors": [
                {
                    "first": "CK",
                    "middle": [],
                    "last": "Peng",
                    "suffix": ""
                },
                {
                    "first": "SV",
                    "middle": [],
                    "last": "Buldyrev",
                    "suffix": ""
                },
                {
                    "first": "AL",
                    "middle": [],
                    "last": "Goldberger",
                    "suffix": ""
                }
            ],
            "year": 1992,
            "venue": "Nature",
            "volume": "356",
            "issn": "6365",
            "pages": "168-170",
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF16": {
            "title": "Fractals related to long DNA sequences and complete genomes",
            "authors": [
                {
                    "first": "BL",
                    "middle": [],
                    "last": "Hao",
                    "suffix": ""
                },
                {
                    "first": "HC",
                    "middle": [],
                    "last": "Lee",
                    "suffix": ""
                },
                {
                    "first": "SY",
                    "middle": [],
                    "last": "Zhang",
                    "suffix": ""
                }
            ],
            "year": 2000,
            "venue": "Chaos, solitons and fractals",
            "volume": "11",
            "issn": "6",
            "pages": "825-836",
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF17": {
            "title": "Fractals and hidden symmetries in DNA",
            "authors": [
                {
                    "first": "C",
                    "middle": [],
                    "last": "Cattani",
                    "suffix": ""
                }
            ],
            "year": 2010,
            "venue": "Mathematical Problems in Engineering",
            "volume": "2010",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        }
    }
}
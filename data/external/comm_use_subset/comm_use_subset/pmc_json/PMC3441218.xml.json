{
    "paper_id": "PMC3441218",
    "metadata": {
        "title": "Arapan-S: a fast and highly accurate whole-genome assembly software for viruses and small genomes",
        "authors": [
            {
                "first": "Mohammed",
                "middle": [],
                "last": "Sahli",
                "suffix": "",
                "email": "mohammed@hgc.jp",
                "affiliation": {}
            },
            {
                "first": "Tetsuo",
                "middle": [],
                "last": "Shibuya",
                "suffix": "",
                "email": "tshibuya@hgc.jp",
                "affiliation": {}
            }
        ]
    },
    "body_text": [
        {
            "text": "Sequencing technologies have been providing us with thousands of sets of genomic reads (sometimes called fragments or segments), with each set being taken from a specific genome. Bringing these reads all together in order to reconstruct the original sequence (the genome) is commonly known as the (whole-) genome assembly problem. This problem has been studied extensively and many assemblers, along with some assembly models, have been proposed. Most models are based either on the overlap graph approach or the de Bruijn graph-based approach. The overlap graph is a graph whose nodes represent the genomic reads, while its edges correspond to the overlaps of these reads. It was the pillar of the first assemblers that appeared on the market, such as: TIGR [1], CAP3 [2], PCAP [3], the string graph of Myers [4] and MIRA [5]. The second category of assemblers is based on the de Bruijn graph, in which the nodes represent the substrings (k-mers) of the genomic reads (which are of the same length), while the edges correspond to the overlaps of these substrings. The de Bruijn graph has become the standard pillar of the so-called \u201cde novo\u201d assemblers. Some of the assemblers based on this approach include: Euler assembler [6], SSAKE [7], EULER-SR [8], Velvet [9,10], ALLPATHS [11,12], ABySS [13], and SOAPdenovo [14]. Although the assemblers share the same graph structure, they use different (but sometimes similar) algorithms to walk through the graph. To our knowledge, there is no proof that the shortest or the longest path, or the Hamiltonian or Eulerian paths will represent the genome in its natural form; therefore, we developed an algorithm that selects only the reliable nodes in the de Bruijn graph in order to reconstruct the original sequence of small genomes or long contigs when the graph is sparse.",
            "cite_spans": [
                {
                    "start": 760,
                    "end": 761,
                    "mention": "1",
                    "ref_id": "BIBREF0"
                },
                {
                    "start": 770,
                    "end": 771,
                    "mention": "2",
                    "ref_id": "BIBREF10"
                },
                {
                    "start": 780,
                    "end": 781,
                    "mention": "3",
                    "ref_id": "BIBREF11"
                },
                {
                    "start": 811,
                    "end": 812,
                    "mention": "4",
                    "ref_id": "BIBREF12"
                },
                {
                    "start": 824,
                    "end": 825,
                    "mention": "5",
                    "ref_id": "BIBREF13"
                },
                {
                    "start": 1227,
                    "end": 1228,
                    "mention": "6",
                    "ref_id": "BIBREF14"
                },
                {
                    "start": 1238,
                    "end": 1239,
                    "mention": "7",
                    "ref_id": "BIBREF15"
                },
                {
                    "start": 1252,
                    "end": 1253,
                    "mention": "8",
                    "ref_id": "BIBREF16"
                },
                {
                    "start": 1264,
                    "end": 1265,
                    "mention": "9",
                    "ref_id": "BIBREF17"
                },
                {
                    "start": 1266,
                    "end": 1268,
                    "mention": "10",
                    "ref_id": "BIBREF1"
                },
                {
                    "start": 1281,
                    "end": 1283,
                    "mention": "11",
                    "ref_id": "BIBREF2"
                },
                {
                    "start": 1284,
                    "end": 1286,
                    "mention": "12",
                    "ref_id": "BIBREF3"
                },
                {
                    "start": 1296,
                    "end": 1298,
                    "mention": "13",
                    "ref_id": "BIBREF4"
                },
                {
                    "start": 1317,
                    "end": 1319,
                    "mention": "14",
                    "ref_id": "BIBREF5"
                }
            ],
            "section": "Background",
            "ref_spans": []
        },
        {
            "text": "Because of the diversity of genomes, creating a general assembler that is able to solve all cases will not be as effective and fast as a specific assembler that focuses on solving particular cases. For instance, ploidy can be a serious problem when dealing with plant genomes in which tetraploidy is common. Concerning very small genomes, we believe that we can improve the accuracy of assembly of such genomes by creating an assembler that is devoted to solving small genomes. That is the reason we aimed to create an assembler (named Arapan-S) dedicated to solving small genomes. As a result, the Arapan-S assembler was able to reconstruct one very highly accurate supercontig in most cases. To check the accuracy of Arapan-S, we performed a BLAST sequence similarity search against the EBI (European Bioinformatics Institute) database, which includes the complete genomes of our dataset. This analysis showed that the Arapan-S assemblies were more than 99% accurate. We also compared Arapan-S with other well known assemblers in the assembly of viral genomes.",
            "cite_spans": [],
            "section": "Background",
            "ref_spans": []
        },
        {
            "text": "Arapan-S was written in C/C++ language under a programming framework called Qt on a 64-bit Linux machine and was also compiled in Windows. The input data must represent each k-mer (i.e. de Bruijn sequence), along with its frequency in the same line, separated by a whitespace character. Note that all frequency values of generated k-mers are based on the coverage level of the dataset. In other words, we have used such frequency values instead of the coverage value. A tool called kmerBuilder, which is one of several assembly pipelines included in the Arapan software package, can generate k-mer files for Arapan-S (i.e. the dataset must be prepared independently from our assembler). The project acronym (Arapan) represents our primary goal to produce a software system that includes a set of open-source tools dedicated to solving and analyzing the whole genome assembly problem.",
            "cite_spans": [],
            "section": "Arapan-S parameters ::: Findings",
            "ref_spans": []
        },
        {
            "text": "The Arapan-S assembler is very sensitive to the length of k of short reads, and because of its architecture our tool always tries to find one supercontig along with its reverse complement. Nevertheless, if the length of k is very short, Arapan-S will encounter some difficulties in constructing the original sequence. Also, if k is very long, the result of the assembly will not be significant. There is always a trade-off between the specificity and sensitivity of choosing the length of k. By experiment, the most appropriate value of k is when 20 \u2264 k \u2264 35.",
            "cite_spans": [],
            "section": "Arapan-S parameters ::: Findings",
            "ref_spans": []
        },
        {
            "text": "Arapan-S has only one parameter, which is the merging function: the frequency function or the k-mer length function. The graphical user interface of Arapan-S represents this parameter by a check-box. During the experiments, it was preferable to choose the frequency function, since it usually leads to a more accurate result. We have considered the frequency function to be the only objective function in our experiments.",
            "cite_spans": [],
            "section": "Arapan-S parameters ::: Findings",
            "ref_spans": []
        },
        {
            "text": "We downloaded some real datasets from the NCBI Trace Archive (ftp://ftp.ncbi.nih.gov/pub/TraceDB/). The data were cleaned and prepared by a trimming tool (http://sourceforge.net/projects/dnascissor/files/DNA%20Scissor/). A minimum quality value cut-off of 20 (i.e. the accuracy of the base call was 99%) was set for most of the genomes, and the low-quality end regions were trimmed at the 5\u2032-end and 3\u2032-end of every read. The short reads (k-mers) were generated by the same trimming tool for each set of reads. The Arapan-S assembler was very fast, used less memory and provided us with one supercontig along with its reverse complement in many cases. For checking the accuracy of our assembler, we searched for the obtained supercontigs (the complete genome) on the EBI database using the NCBI BLAST Similarity Search. The input data are given in Table 1, while Table 2, Table 3, Table 4 and Table 5 show the results.",
            "cite_spans": [],
            "section": "BLAST similarity search ::: Findings",
            "ref_spans": [
                {
                    "start": 854,
                    "end": 855,
                    "mention": "1",
                    "ref_id": "TABREF0"
                },
                {
                    "start": 869,
                    "end": 870,
                    "mention": "2",
                    "ref_id": "TABREF1"
                },
                {
                    "start": 878,
                    "end": 879,
                    "mention": "3",
                    "ref_id": "TABREF2"
                },
                {
                    "start": 887,
                    "end": 888,
                    "mention": "4",
                    "ref_id": "TABREF3"
                },
                {
                    "start": 899,
                    "end": 900,
                    "mention": "5",
                    "ref_id": "TABREF4"
                }
            ]
        },
        {
            "text": "The total length of each genome was very close to the genome length obtained from the EBI database, and yielded very high identities (Table 2). Moreover, to show the robustness of Arapan-S, we compared its results to other well-known assemblers: ABySS-1.2.7 [13], SSAKE 3.7 [7], Velvet 1.1.3 [9,10] and QSRA [15]. The Overlap-Layout-Consensus-based assemblers that were included for comparison were: Minimus [16] and Mira [5,17]. The selected version of each assembler was the latest release, except for the SSAKE assembler for which we chose the release SSAKE 3.7 instead of SSAKE 3.8 because of installation problems. All assemblers have been run with default parameters.",
            "cite_spans": [
                {
                    "start": 259,
                    "end": 261,
                    "mention": "13",
                    "ref_id": "BIBREF4"
                },
                {
                    "start": 275,
                    "end": 276,
                    "mention": "7",
                    "ref_id": "BIBREF15"
                },
                {
                    "start": 293,
                    "end": 294,
                    "mention": "9",
                    "ref_id": "BIBREF17"
                },
                {
                    "start": 295,
                    "end": 297,
                    "mention": "10",
                    "ref_id": "BIBREF1"
                },
                {
                    "start": 309,
                    "end": 311,
                    "mention": "15",
                    "ref_id": "BIBREF6"
                },
                {
                    "start": 409,
                    "end": 411,
                    "mention": "16",
                    "ref_id": "BIBREF7"
                },
                {
                    "start": 423,
                    "end": 424,
                    "mention": "5",
                    "ref_id": "BIBREF13"
                },
                {
                    "start": 425,
                    "end": 427,
                    "mention": "17",
                    "ref_id": "BIBREF8"
                }
            ],
            "section": "BLAST similarity search ::: Findings",
            "ref_spans": [
                {
                    "start": 140,
                    "end": 141,
                    "mention": "2",
                    "ref_id": "TABREF1"
                }
            ]
        },
        {
            "text": "Concerning the de novo assemblers, the most competitive assembler to Arapan-S was ABySS in Table 3. As with Arapan-S, ABySS was also able to produce only one supercontig for the Bovine Respiratory Coronavirus AH187 genome and the Waterbuck Coronavirus US/OH WD358 TC/1994 genome. However, in contrast to ABySS, Arapan-S achieved the greatest genome coverage and only one supercontig in all cases. Since Arapan-S generated only one contig in all cases, it produced the largest contigs compared to other assemblers. In contrast, the other assemblers generated more contigs and SSAKE had the lowest genome coverage every time and more contigs most of the time. QSRA also did not work well with small genomes.",
            "cite_spans": [],
            "section": "De novo assembler competitors ::: Comparison ::: Findings",
            "ref_spans": [
                {
                    "start": 97,
                    "end": 98,
                    "mention": "3",
                    "ref_id": "TABREF2"
                }
            ]
        },
        {
            "text": "The Influenza A Virus genome consists of eight segments (http://bioafrica.mrc.ac.za/rnavirusdb/virus.php?id=335341). Table 4 shows that Arapan-S was able to detect the eight contigs of different genomes of type Influenza A Virus. According to our empirical results, SSAKE failed to deal with small viral genomes. N50 values of SSAKE were not computed because its results did not cover half of the entire genome. ABySS was again the second best assembler after Arapan-S. However, our assembler succeeded in determining the eight segments of each genome, such that its N50 values, as well as the largest contig, were always the highest compared to other assemblers.",
            "cite_spans": [],
            "section": "De novo assembler competitors ::: Comparison ::: Findings",
            "ref_spans": [
                {
                    "start": 123,
                    "end": 124,
                    "mention": "4",
                    "ref_id": "TABREF3"
                }
            ]
        },
        {
            "text": "Among the Overlap-Layout-Consensus-based assemblers, Arapan-S was comparable to Minimus. Minimus failed in one case, Influenza A Virus A/Memphis/1/71(H3N2), in which it produced nine contigs instead of eight (Table 4). Our assembler showed good approximation compared to Minimus for the Antelope coronavirus US/OH1/2003 genome (Table 5). They achieved almost the same result for the Waterbuck Coronavirus US/OH-WD358-TC/1994 and the White-tailed Deer Coronavirus US/OH-WD470/1994 genomes. On the other hand, Mira did not work well with small genomes, as shown in Tables 3, 4 and 5.",
            "cite_spans": [],
            "section": "Overlap-layout-consensus competitors ::: Comparison ::: Findings",
            "ref_spans": [
                {
                    "start": 215,
                    "end": 216,
                    "mention": "4",
                    "ref_id": "TABREF3"
                },
                {
                    "start": 334,
                    "end": 335,
                    "mention": "5",
                    "ref_id": "TABREF4"
                },
                {
                    "start": 570,
                    "end": 571,
                    "mention": "3",
                    "ref_id": "TABREF2"
                },
                {
                    "start": 573,
                    "end": 574,
                    "mention": "4",
                    "ref_id": "TABREF3"
                },
                {
                    "start": 579,
                    "end": 580,
                    "mention": "5",
                    "ref_id": "TABREF4"
                }
            ]
        },
        {
            "text": "We have relied on only one objective function \u201cthe frequency function\u201d for the sequence assembly algorithm. In fact, one may also consider another function, which is, \u201cthe k-mer length function\u201d, g(L)=\u03a3iN=1aili, such that L=l1,l2,K,lN such that is the set of k-mer lengths. This function is based on the assumption that nodes whose k-mers have longer, relative to shorter, lengths are more probably generated from trustworthy consecutive nodes, that is to say, a chain that has fewer or no sequencing errors. However, we have considered only the frequency function in the analysis presented here.",
            "cite_spans": [],
            "section": "Discussion",
            "ref_spans": []
        },
        {
            "text": "In the case of non-uniform coverage of some areas in the genome [18], the frequency function may suffer from less accuracy. On the other hand, we believe that the k-mer length function can be a good choice in the case of coverage non-uniformity. Building an algorithm that combines the two objective functions and switches from one to another may lead to more accurate results. Creating such an effective algorithm is an important issue for future research.",
            "cite_spans": [
                {
                    "start": 65,
                    "end": 67,
                    "mention": "18",
                    "ref_id": "BIBREF9"
                }
            ],
            "section": "Discussion",
            "ref_spans": []
        },
        {
            "text": "Another thing that can be said about the objective function is that the assembly algorithm does not look for the optimal solution. As a matter of fact, the algorithm starts at a determined node whose associated k-mer has the longest length, then starts going forward and backward in the graph selecting nodes that have the highest scores (greatest frequency values) locally in order to construct a contiguous path in a given connected component.",
            "cite_spans": [],
            "section": "Discussion",
            "ref_spans": []
        },
        {
            "text": "We have noticed that most genome assemblers, which were built for tackling medium or large genomes, could not successfully deal with tiny and small genomes. Arapan-S, ABySS and Minimus were able to deal with such cases. In future work a comparison would be worthwhile for all genome assemblers to determine the efficiency field of each set of assemblers.",
            "cite_spans": [],
            "section": "Discussion",
            "ref_spans": []
        },
        {
            "text": "Since our aim was creating a genome assembler for tackling only tiny genomes, dealing with repeats was not an essential task, since they do not regularly appear in very small genomes and the confrontation with tandem repeats does not generally mislead the assembly process (according to our experience). However, in the future, we aim to build another version of the Arapan-S assembler that can handle longer genomes.",
            "cite_spans": [],
            "section": "Discussion",
            "ref_spans": []
        },
        {
            "text": "According to our experiments, we have found that general assemblers are not always as effective as the Arapan-S assembler in dealing with tiny genomes. We have used only long reads in our experiments, because the raw data of small genomes can be easily found in the NCBI Trace Archive. However, our assembler can work with any other sequencing technology, such as Illumina/Solexa, SOLiD and 454 sequencing technologies. The raw data are converted into a set of k-mers by kmerBuilder (http://sourceforge.net/projects/dnascissor/files/kmerBuilder/). The user can run Arapan-S assembler by providing it with the k-mer file. This feature represents another advantage of our assembler compared to other assemblers. Arapan-S is fast and uses less memory. However, because we are dealing with small genomes, the time and space complexities of all assemblers were negligible. Our assembler is not designed to be applied to medium or large genomes.",
            "cite_spans": [],
            "section": "Conclusions",
            "ref_spans": []
        },
        {
            "text": "The entire dataset of k-mers is recorded using hash tables in order to speed up further operations. The reverse complements are also recorded without binding them with their original k-mers. All we need is a linear algorithm for constructing the de Bruijn graph. Since the alphabet is composed of four nucleotide letters, each k-mer will be connected to four k-mers at most. All k-mers that include unknown \u2018N\u2019 nucleotides are discarded. The pseudo-code of the algorithm is shown below:",
            "cite_spans": [],
            "section": "Input data and graph construction ::: Methods",
            "ref_spans": []
        },
        {
            "text": "1. deBruijnGraphBuilder(HashTable kmerList, integerK)",
            "cite_spans": [],
            "section": "Input data and graph construction ::: Methods",
            "ref_spans": []
        },
        {
            "text": "2. IntegerN :=|kmerList|; //the size of kmerList",
            "cite_spans": [],
            "section": "Input data and graph construction ::: Methods",
            "ref_spans": []
        },
        {
            "text": "3. Stringtemp;",
            "cite_spans": [],
            "section": "Input data and graph construction ::: Methods",
            "ref_spans": []
        },
        {
            "text": "4. fori:=1 toNdo",
            "cite_spans": [],
            "section": "Input data and graph construction ::: Methods",
            "ref_spans": []
        },
        {
            "text": "5. begin",
            "cite_spans": [],
            "section": "Input data and graph construction ::: Methods",
            "ref_spans": []
        },
        {
            "text": "6. temp := kmerList[i][1..K\u22121];",
            "cite_spans": [],
            "section": "Input data and graph construction ::: Methods",
            "ref_spans": []
        },
        {
            "text": "7. //forward connection",
            "cite_spans": [],
            "section": "Input data and graph construction ::: Methods",
            "ref_spans": []
        },
        {
            "text": "8. iftemp+\u201cA\u201d kmerListthen createArc( i, kmerList.IndexOf(temp+\u201cA\u201d));",
            "cite_spans": [],
            "section": "Input data and graph construction ::: Methods",
            "ref_spans": []
        },
        {
            "text": "9. iftemp+\u201cT\u201d kmerListthen createArc( i, kmerList.IndexOf(temp+\u201cT\u201d));",
            "cite_spans": [],
            "section": "Input data and graph construction ::: Methods",
            "ref_spans": []
        },
        {
            "text": "10. iftemp+\u201cC\u201d kmerListthen createArc( i, kmerList.IndexOf(temp+\u201cC\u201d));",
            "cite_spans": [],
            "section": "Input data and graph construction ::: Methods",
            "ref_spans": []
        },
        {
            "text": "11. iftemp+\u201cG\u201d kmerListthen createArc( i, kmerList.IndexOf(temp+\u201cG\u201d));",
            "cite_spans": [],
            "section": "Input data and graph construction ::: Methods",
            "ref_spans": []
        },
        {
            "text": "12. //backward connection",
            "cite_spans": [],
            "section": "Input data and graph construction ::: Methods",
            "ref_spans": []
        },
        {
            "text": "13. if \u201cA\u201d+ temp kmerListthen createArc(kmerList.IndexOf(\u201cA\u201d+ temp), i );",
            "cite_spans": [],
            "section": "Input data and graph construction ::: Methods",
            "ref_spans": []
        },
        {
            "text": "14. if \u201cT\u201d+ temp kmerListthen createArc(kmerList.IndexOf(\u201cT\u201d+ temp), i );",
            "cite_spans": [],
            "section": "Input data and graph construction ::: Methods",
            "ref_spans": []
        },
        {
            "text": "15. if \u201cC\u201d+ temp kmerListthen createArc(kmerList.IndexOf(\u201cC\u201d+ temp), i )",
            "cite_spans": [],
            "section": "Input data and graph construction ::: Methods",
            "ref_spans": []
        },
        {
            "text": "16. if \u201cG\u201d+ temp kmerListthen createArc(kmerList.IndexOf(\u201cG\u201d+ temp), i);",
            "cite_spans": [],
            "section": "Input data and graph construction ::: Methods",
            "ref_spans": []
        },
        {
            "text": "17. end",
            "cite_spans": [],
            "section": "Input data and graph construction ::: Methods",
            "ref_spans": []
        },
        {
            "text": "Let K be the length of the short reads. The variable temp will contain the first prefix of a given K-mer whose length is K \u2212 1. The algorithm computes the out-neighbours in the forward orientation, and the in-neighbours in the opposite direction.",
            "cite_spans": [],
            "section": "Input data and graph construction ::: Methods",
            "ref_spans": []
        },
        {
            "text": "To simplify and shrink the graph before applying any cleaning procedure, a path collapsing algorithm should be run immediately after constructing the graph.",
            "cite_spans": [],
            "section": "Path collapsing ::: Cleaning process (simplifying the graph and solving errors) ::: Methods",
            "ref_spans": []
        },
        {
            "text": "A path is a chain of nodes. Two nodes X and Y are merged if the node X has only one outgoing arc connected to the node Y that has only one incoming arc. Their corresponding k-mers must be concatenated accordingly. Most of the resulting nodes (we call them switch nodes) are seen in Figure 3.",
            "cite_spans": [],
            "section": "Path collapsing ::: Cleaning process (simplifying the graph and solving errors) ::: Methods",
            "ref_spans": [
                {
                    "start": 289,
                    "end": 290,
                    "mention": "3",
                    "ref_id": "FIGREF2"
                }
            ]
        },
        {
            "text": "In genome assembly, a bubble appears where two sequences initially align, then diverge in the middle, and align again at the end. Bubbles are caused by repeats or heterozygotes of diploid chromosomes [14], or created by errors or biological variants, such as SNPs, diploids or cloning artefacts prior to sequencing.",
            "cite_spans": [
                {
                    "start": 201,
                    "end": 203,
                    "mention": "14",
                    "ref_id": "BIBREF5"
                }
            ],
            "section": "Bubble solving ::: Cleaning process (simplifying the graph and solving errors) ::: Methods",
            "ref_spans": []
        },
        {
            "text": "A path is a chain of nodes in a graph. We call a path a simple path if each internal node (i.e., each node between the start node and the end node of the path) has one outgoing edge and one incoming edge. A bubble is a subgraph that consists of multiple simple paths all of which share the same start node and the same end node. In the original graph, the start node must not have any outgoing edges other than those in the bubble, and the end node must not have any incoming edges other than those in the bubble.",
            "cite_spans": [],
            "section": "Bubble solving ::: Cleaning process (simplifying the graph and solving errors) ::: Methods",
            "ref_spans": []
        },
        {
            "text": "In Velvet [9,10], detection of bubbles was done by an algorithm based on a Dijkstra-like breadth-first search called \u201cThe Tour Bus Algorithm\u201d. Similarly, Dijkstra\u2019s algorithm is also used to detect bubbles in SOAPdenovo [14], in which the detected bubbles are merged into a single path if the sequences of the parallel paths are very similar; that is, had fewer than four base pairs difference with more than 90% identity.",
            "cite_spans": [
                {
                    "start": 11,
                    "end": 12,
                    "mention": "9",
                    "ref_id": "BIBREF17"
                },
                {
                    "start": 13,
                    "end": 15,
                    "mention": "10",
                    "ref_id": "BIBREF1"
                },
                {
                    "start": 221,
                    "end": 223,
                    "mention": "14",
                    "ref_id": "BIBREF5"
                }
            ],
            "section": "Bubble solving ::: Cleaning process (simplifying the graph and solving errors) ::: Methods",
            "ref_spans": []
        },
        {
            "text": "In Arapan-S, all bubbles will be relaxed by combining all the cleaning procedures and without incorporating a time-consuming algorithm. After collapsing all paths, bubbles will appear in the graph as shown in Figure 1. The node with a high coverage will not be removed from the bubble (However, the algorithm can also be parameterized to keep only the node that has the maximum k-mer\u2019s length instead of high coverage).",
            "cite_spans": [],
            "section": "Bubble solving ::: Cleaning process (simplifying the graph and solving errors) ::: Methods",
            "ref_spans": [
                {
                    "start": 216,
                    "end": 217,
                    "mention": "1",
                    "ref_id": "FIGREF0"
                }
            ]
        },
        {
            "text": "Tips generally result from errors at the end of reads. In the graph, a tip is a node connected only on one end (Figure 4). In Velvet, a tip is removed if it is shorter than 2 k (k is chosen for the k-mer). After removing tips, new paths will appear again in the graph. Almost all the remaining nodes\u2019 degrees are \u2265 2. We will hereafter call such nodes: switch nodes. The result of the cleaning process will be similar to what is shown in Figure 5.",
            "cite_spans": [],
            "section": "Tips removal ::: Cleaning process (simplifying the graph and solving errors) ::: Methods",
            "ref_spans": [
                {
                    "start": 119,
                    "end": 120,
                    "mention": "4",
                    "ref_id": "FIGREF3"
                },
                {
                    "start": 445,
                    "end": 446,
                    "mention": "5",
                    "ref_id": "FIGREF4"
                }
            ]
        },
        {
            "text": "Once the graph is reduced and contains only switch nodes, we start determining the connected components of the graph. There are two cases in which we need to determine the connected component. The first case is the nature of the k-mers and their reverse complements. Since each k-mer was recorded along with its reverse complement, we will obtain a graph composed of two subgraphs, one being the reverse of the other. The second case is the sparseness of the graph, especially when the initial k-mer length is a bit longer. Our assembly algorithm can run on every connected component of the graph. Detection of these components can lead the assembly algorithm to be run in parallel. The breadth-first search or depth-first search can be applied to find the connected components in linear time. The search begins at an arbitrary node v from which the entire connected component including v will be detected. A loop through all nodes of the graph must be implemented in order to find all the connected components. The loop runs until no visited node can be found. The pseudo-code of the modified algorithm is shown as follows:",
            "cite_spans": [],
            "section": "Connected components detection ::: Methods",
            "ref_spans": []
        },
        {
            "text": "1. connectedComponent(VertexSetV, EdgeSetE, Nodea)",
            "cite_spans": [],
            "section": "Connected components detection ::: Methods",
            "ref_spans": []
        },
        {
            "text": "2. SetX;",
            "cite_spans": [],
            "section": "Connected components detection ::: Methods",
            "ref_spans": []
        },
        {
            "text": "3. Booleanvisited[|V|];",
            "cite_spans": [],
            "section": "Connected components detection ::: Methods",
            "ref_spans": []
        },
        {
            "text": "4. //Step 1",
            "cite_spans": [],
            "section": "Connected components detection ::: Methods",
            "ref_spans": []
        },
        {
            "text": "5. X:=X\u222aa;",
            "cite_spans": [],
            "section": "Connected components detection ::: Methods",
            "ref_spans": []
        },
        {
            "text": "6. visitedx:=false,\u2200x\u2208V;",
            "cite_spans": [],
            "section": "Connected components detection ::: Methods",
            "ref_spans": []
        },
        {
            "text": "7. //Step 2",
            "cite_spans": [],
            "section": "Connected components detection ::: Methods",
            "ref_spans": []
        },
        {
            "text": "8. while\u2203x\u2208X|visitedx=falsedo",
            "cite_spans": [],
            "section": "Connected components detection ::: Methods",
            "ref_spans": []
        },
        {
            "text": "9. begin",
            "cite_spans": [],
            "section": "Connected components detection ::: Methods",
            "ref_spans": []
        },
        {
            "text": "10. \u2203x\u2208X|visitedx=false;",
            "cite_spans": [],
            "section": "Connected components detection ::: Methods",
            "ref_spans": []
        },
        {
            "text": "11. X:=X\u222ay,\u2200x,y\u2208Eory,x\u2208E|y\u2209X;",
            "cite_spans": [],
            "section": "Connected components detection ::: Methods",
            "ref_spans": []
        },
        {
            "text": "12. end",
            "cite_spans": [],
            "section": "Connected components detection ::: Methods",
            "ref_spans": []
        },
        {
            "text": "13. returnX;",
            "cite_spans": [],
            "section": "Connected components detection ::: Methods",
            "ref_spans": []
        },
        {
            "text": "The idea of this algorithm is to traverse the graph from an arbitrary node a, mark it as a visited node and record its neighbors in the set X. The same job is done for the recorded nodes until there are no visited nodes in the set X. The algorithm returns the connected component engendered from the node a. To find all connected components we apply the following algorithm:",
            "cite_spans": [],
            "section": "Connected components detection ::: Methods",
            "ref_spans": []
        },
        {
            "text": "1. allComponents(VertexSetV, EdgeSetE)",
            "cite_spans": [],
            "section": "Connected components detection ::: Methods",
            "ref_spans": []
        },
        {
            "text": "2. SetListC;",
            "cite_spans": [],
            "section": "Connected components detection ::: Methods",
            "ref_spans": []
        },
        {
            "text": "3. SetX\u2019 ;",
            "cite_spans": [],
            "section": "Connected components detection ::: Methods",
            "ref_spans": []
        },
        {
            "text": "4. Integeri;",
            "cite_spans": [],
            "section": "Connected components detection ::: Methods",
            "ref_spans": []
        },
        {
            "text": "5. //Step1",
            "cite_spans": [],
            "section": "Connected components detection ::: Methods",
            "ref_spans": []
        },
        {
            "text": "6. X':=V;",
            "cite_spans": [],
            "section": "Connected components detection ::: Methods",
            "ref_spans": []
        },
        {
            "text": "7. i:=1;",
            "cite_spans": [],
            "section": "Connected components detection ::: Methods",
            "ref_spans": []
        },
        {
            "text": "8. //Step 2",
            "cite_spans": [],
            "section": "Connected components detection ::: Methods",
            "ref_spans": []
        },
        {
            "text": "9. whileX'\u2260\u00d8do",
            "cite_spans": [],
            "section": "Connected components detection ::: Methods",
            "ref_spans": []
        },
        {
            "text": "10. begin",
            "cite_spans": [],
            "section": "Connected components detection ::: Methods",
            "ref_spans": []
        },
        {
            "text": "11. select an arbitrary x\u2208X\u2019;",
            "cite_spans": [],
            "section": "Connected components detection ::: Methods",
            "ref_spans": []
        },
        {
            "text": "12. Ci:=connectedComponent(G,x);",
            "cite_spans": [],
            "section": "Connected components detection ::: Methods",
            "ref_spans": []
        },
        {
            "text": "13. X':X'\u2212Ci;",
            "cite_spans": [],
            "section": "Connected components detection ::: Methods",
            "ref_spans": []
        },
        {
            "text": "14. i:=i+1;",
            "cite_spans": [],
            "section": "Connected components detection ::: Methods",
            "ref_spans": []
        },
        {
            "text": "15. end",
            "cite_spans": [],
            "section": "Connected components detection ::: Methods",
            "ref_spans": []
        },
        {
            "text": "16. returnC;",
            "cite_spans": [],
            "section": "Connected components detection ::: Methods",
            "ref_spans": []
        },
        {
            "text": "We only need to select an arbitrary node x and determine, due to the connectedComponent() procedure, the connected component Ci having x. The determined component\u2019s nodes will be removed from the X\u2019 (Line 14). The same operation is performed until no connected components can be detected.",
            "cite_spans": [],
            "section": "Connected components detection ::: Methods",
            "ref_spans": []
        },
        {
            "text": "Once the connected components are detected, we run the assembly algorithm for each component. The assembly algorithm can be run by using one of two parameters: the coverage (k-mer\u2019s frequency), and the k-mer lengths. The latter parameter is obtained by the cleaning process, which provides us with switch nodes whose corresponding k-mers have longer lengths due to the merging process.",
            "cite_spans": [],
            "section": "Assembly algorithm ::: Methods",
            "ref_spans": []
        },
        {
            "text": "Most of the previous work on genome assembly has the following assumption: given a set of reads, the objective of the assembly program is to minimize the length of the assembled genome [18]. However, according to our knowledge, there is no proof that the shortest path can always faithfully represent the genome. The same can be concluded concerning the longest path, the Hamiltonian path and the Eulerian path.",
            "cite_spans": [
                {
                    "start": 186,
                    "end": 188,
                    "mention": "18",
                    "ref_id": "BIBREF9"
                }
            ],
            "section": "Assembly algorithm ::: Methods",
            "ref_spans": []
        },
        {
            "text": "The assembly algorithm is a greedy function. It traverses the graph by selecting only the nodes whose frequency values are higher. We have chosen this strategy by assuming that k-mers, which are characterized by high frequency values, are more likely to be free of sequencing errors (we call it \u201cfrequency function\u201d). All procedures of the assembly algorithm are given as follows:",
            "cite_spans": [],
            "section": "Assembly algorithm ::: Methods",
            "ref_spans": []
        },
        {
            "text": "1. stringPath( SetC)",
            "cite_spans": [],
            "section": "Assembly algorithm ::: Methods",
            "ref_spans": []
        },
        {
            "text": "2. Ordered Setpath;",
            "cite_spans": [],
            "section": "Assembly algorithm ::: Methods",
            "ref_spans": []
        },
        {
            "text": "3. SetP, Visited;",
            "cite_spans": [],
            "section": "Assembly algorithm ::: Methods",
            "ref_spans": []
        },
        {
            "text": "4. Nodeu, v;",
            "cite_spans": [],
            "section": "Assembly algorithm ::: Methods",
            "ref_spans": []
        },
        {
            "text": "5. //Step1: preprocessing",
            "cite_spans": [],
            "section": "Assembly algorithm ::: Methods",
            "ref_spans": []
        },
        {
            "text": "6. u := the index of the node which have the longest k-mer length.",
            "cite_spans": [],
            "section": "Assembly algorithm ::: Methods",
            "ref_spans": []
        },
        {
            "text": "7. v:=u;",
            "cite_spans": [],
            "section": "Assembly algorithm ::: Methods",
            "ref_spans": []
        },
        {
            "text": "8. path:=path\u222au;",
            "cite_spans": [],
            "section": "Assembly algorithm ::: Methods",
            "ref_spans": []
        },
        {
            "text": "9. Visited: =\u00d8",
            "cite_spans": [],
            "section": "Assembly algorithm ::: Methods",
            "ref_spans": []
        },
        {
            "text": "10. //Step 2: forward direction",
            "cite_spans": [],
            "section": "Assembly algorithm ::: Methods",
            "ref_spans": []
        },
        {
            "text": "11. do forever",
            "cite_spans": [],
            "section": "Assembly algorithm ::: Methods",
            "ref_spans": []
        },
        {
            "text": "12. begin",
            "cite_spans": [],
            "section": "Assembly algorithm ::: Methods",
            "ref_spans": []
        },
        {
            "text": "13. P := out_neighbors(u) \u2212 Visited;",
            "cite_spans": [],
            "section": "Assembly algorithm ::: Methods",
            "ref_spans": []
        },
        {
            "text": "14. Visited:=Visited\u222aP;",
            "cite_spans": [],
            "section": "Assembly algorithm ::: Methods",
            "ref_spans": []
        },
        {
            "text": "15. ifP=\u00d8 thenstop;",
            "cite_spans": [],
            "section": "Assembly algorithm ::: Methods",
            "ref_spans": []
        },
        {
            "text": "16. u := bestNeighbor(u, P);",
            "cite_spans": [],
            "section": "Assembly algorithm ::: Methods",
            "ref_spans": []
        },
        {
            "text": "17. path:=path\u222au;",
            "cite_spans": [],
            "section": "Assembly algorithm ::: Methods",
            "ref_spans": []
        },
        {
            "text": "18. End",
            "cite_spans": [],
            "section": "Assembly algorithm ::: Methods",
            "ref_spans": []
        },
        {
            "text": "19. //Step 3: backward direction",
            "cite_spans": [],
            "section": "Assembly algorithm ::: Methods",
            "ref_spans": []
        },
        {
            "text": "20. do forever",
            "cite_spans": [],
            "section": "Assembly algorithm ::: Methods",
            "ref_spans": []
        },
        {
            "text": "21. begin",
            "cite_spans": [],
            "section": "Assembly algorithm ::: Methods",
            "ref_spans": []
        },
        {
            "text": "22. P := in_neighbors(v) \u2212 Visited;",
            "cite_spans": [],
            "section": "Assembly algorithm ::: Methods",
            "ref_spans": []
        },
        {
            "text": "23. Visited:=Visited\u222aP;",
            "cite_spans": [],
            "section": "Assembly algorithm ::: Methods",
            "ref_spans": []
        },
        {
            "text": "24. ifP=\u00d8thenstop;",
            "cite_spans": [],
            "section": "Assembly algorithm ::: Methods",
            "ref_spans": []
        },
        {
            "text": "25. v := bestNeighbor(v, P);",
            "cite_spans": [],
            "section": "Assembly algorithm ::: Methods",
            "ref_spans": []
        },
        {
            "text": "26. path:=v\u222apath;",
            "cite_spans": [],
            "section": "Assembly algorithm ::: Methods",
            "ref_spans": []
        },
        {
            "text": "27. end",
            "cite_spans": [],
            "section": "Assembly algorithm ::: Methods",
            "ref_spans": []
        },
        {
            "text": "28. returnpath;",
            "cite_spans": [],
            "section": "Assembly algorithm ::: Methods",
            "ref_spans": []
        },
        {
            "text": "The set C represents a connected component of the graph. The resulting path is kept in the ordered set path. After variables initialization, the algorithm goes in a forward direction selecting the best out-neighbors. In the last step, it goes backwards selecting the best in-neighbors. The bestNeighbor() function is the current node and the set of its in- or out-neighbors. Since each node could be connected to several neighbouring nodes, the best neighbor is characterized by the highest frequency value. The two loops stop when no more exploration can be done. To find all possible paths, we apply the following algorithm, called the stringPath() algorithm.",
            "cite_spans": [],
            "section": "Assembly algorithm ::: Methods",
            "ref_spans": []
        },
        {
            "text": "1. allPaths()",
            "cite_spans": [],
            "section": "Assembly algorithm ::: Methods",
            "ref_spans": []
        },
        {
            "text": "2. SetListC; //components list",
            "cite_spans": [],
            "section": "Assembly algorithm ::: Methods",
            "ref_spans": []
        },
        {
            "text": "3. SetListP; //paths list",
            "cite_spans": [],
            "section": "Assembly algorithm ::: Methods",
            "ref_spans": []
        },
        {
            "text": "4. Integeri;",
            "cite_spans": [],
            "section": "Assembly algorithm ::: Methods",
            "ref_spans": []
        },
        {
            "text": "5. //Step 1",
            "cite_spans": [],
            "section": "Assembly algorithm ::: Methods",
            "ref_spans": []
        },
        {
            "text": "6. C:=allComponents(G);",
            "cite_spans": [],
            "section": "Assembly algorithm ::: Methods",
            "ref_spans": []
        },
        {
            "text": "7. //Step 2",
            "cite_spans": [],
            "section": "Assembly algorithm ::: Methods",
            "ref_spans": []
        },
        {
            "text": "8. fori:= 1 to |C| do",
            "cite_spans": [],
            "section": "Assembly algorithm ::: Methods",
            "ref_spans": []
        },
        {
            "text": "9. begin",
            "cite_spans": [],
            "section": "Assembly algorithm ::: Methods",
            "ref_spans": []
        },
        {
            "text": "10. Pi:=stringPath(Ci);",
            "cite_spans": [],
            "section": "Assembly algorithm ::: Methods",
            "ref_spans": []
        },
        {
            "text": "11. end",
            "cite_spans": [],
            "section": "Assembly algorithm ::: Methods",
            "ref_spans": []
        },
        {
            "text": "12. returnP;",
            "cite_spans": [],
            "section": "Assembly algorithm ::: Methods",
            "ref_spans": []
        },
        {
            "text": "By going through all connected components (determined by the allComponents() procedure), and due to the previous algorithm, a path Pi will be constructed for each connected component Ci.",
            "cite_spans": [],
            "section": "Assembly algorithm ::: Methods",
            "ref_spans": []
        },
        {
            "text": "Arapan-S is open access and freely available. All questions, comments and requests should be sent by email to nihon.sahli@gmail.com.",
            "cite_spans": [],
            "section": "Availability and requirements ::: Methods",
            "ref_spans": []
        },
        {
            "text": "Project name: Arapan project",
            "cite_spans": [],
            "section": "Availability and requirements ::: Methods",
            "ref_spans": []
        },
        {
            "text": "Project home page: http://shibuyalab.hgc.jp/Arapan/",
            "cite_spans": [],
            "section": "Availability and requirements ::: Methods",
            "ref_spans": []
        },
        {
            "text": "Operating system(s): Windows, Linux (Ubuntu)",
            "cite_spans": [],
            "section": "Availability and requirements ::: Methods",
            "ref_spans": []
        },
        {
            "text": "Programming language: C/C++",
            "cite_spans": [],
            "section": "Availability and requirements ::: Methods",
            "ref_spans": []
        },
        {
            "text": "Other requirements: None",
            "cite_spans": [],
            "section": "Availability and requirements ::: Methods",
            "ref_spans": []
        },
        {
            "text": "License: None required",
            "cite_spans": [],
            "section": "Availability and requirements ::: Methods",
            "ref_spans": []
        },
        {
            "text": "Any restrictions to use by non-academics: None required",
            "cite_spans": [],
            "section": "Availability and requirements ::: Methods",
            "ref_spans": []
        },
        {
            "text": "The authors declare that they have no competing interests.",
            "cite_spans": [],
            "section": "Competing interests",
            "ref_spans": []
        },
        {
            "text": "MS and TS conceived the research and wrote the article. MS conducted the research and implemented Arapan-S in C++ programming language. All authors have read and approved the final manuscript.",
            "cite_spans": [],
            "section": "Authors\u2019 contributions",
            "ref_spans": []
        }
    ],
    "ref_entries": {
        "TABREF0": {
            "text": "Table 1: The input data include seven Virus Genomes\nWe considered eight viruses. The genome of each Influenza A Virus consists of eight segments while the others have only one long segment. The datasets represent Sanger reads. The raw data were downloaded from NCBI Trace Archive (ftp://ftp.ncbi.nih.gov/pub/TraceDB/.)",
            "type": "table"
        },
        "TABREF1": {
            "text": "Table 2: The Alignment Results By Using the EBI database (BLAST Similarity Search) on seven Virus Genomes\nThe Total length is the length of the obtained result, while Genome length (EBI) is the genome\u2019s supposed length according to the EBI database. The values of Identities were calculated by dividing Alignment scores by the corresponding Total lengths. The Expect-value was calculated by EBI\u2019s NCBI BLAST Similarity Search engine.",
            "type": "table"
        },
        "TABREF2": {
            "text": "Table 3: Comparison of Arapan-S with ABySS, SSAKE, Velvet, QSRA, Minimus and Mira assemblers on four Benchmark Virus Genomes\nOnly contigs whose lengths \u2265 800 were selected. When the assembler generated only one contig, the N50 value and the mean size are equal to the size of the corresponding contig. Genome coverage was calculated by dividing the total length by the genome length (EBI).",
            "type": "table"
        },
        "TABREF3": {
            "text": "Table 4: Comparison of Arapan-S with all the assemblers on Three Genomes Composed of eight Segments\nOnly contigs whose lengths \u2265 400 were selected. Each species has eight segments that constitute its genome.",
            "type": "table"
        },
        "TABREF4": {
            "text": "Table 5: Comparison of Arapan-S with all QSRA, Minimus and Mira assemblers onAntelope coronavirus US/OH1/2003genome\nOnly contigs whose lengths \u2265 400 were selected.",
            "type": "table"
        },
        "FIGREF0": {
            "text": "Figure 1: Flowchart. The different phases of the cleaning algorithm. ",
            "type": "figure"
        },
        "FIGREF1": {
            "text": "Figure 2: Switch node. All contiguous nodes are merged in one node. This operation is named \u201cThe path collapsing.\u201d",
            "type": "figure"
        },
        "FIGREF2": {
            "text": "Figure 3: Bubbles. This figure illustrates three simple bubbles and two complex bubbles. Simple bubbles are A-C, B-D and E-F. The first complex bubble starts at A and ends at D while the second one starts at D and ends at F. (X-Y is the subgraph that starts at X and ends at Y). Complex bubbles are solved by executing the simple bubble-solving algorithm and path-collapsing algorithm.",
            "type": "figure"
        },
        "FIGREF3": {
            "text": "Figure 4: Tips. This figure shows some tips (i.e. C, D, F and I).",
            "type": "figure"
        },
        "FIGREF4": {
            "text": "Figure 5: Graph visualization. A part of two connected components of the white tailed deer corona virus genome graph after running the cleaning algorithm. Nodes represent k-mers and arrows represent the overlaps between k-mers. This picture was taken from the aiSee graph visualization software (www.aisee.com.)",
            "type": "figure"
        }
    },
    "back_matter": [],
    "bib_entries": {
        "BIBREF0": {
            "title": "TIGR Assembler: a new tool for assembling large shotgun sequencing projects",
            "authors": [],
            "year": 1995,
            "venue": "Genome Sci",
            "volume": "1",
            "issn": "",
            "pages": "9-19",
            "other_ids": {
                "DOI": [
                    "10.1089/gst.1995.1.9"
                ]
            }
        },
        "BIBREF1": {
            "title": "Pebble and rock band: heuristic resolution of repeats and scaffolding in the velvet short read de novo assembler",
            "authors": [],
            "year": 2009,
            "venue": "PLoS One",
            "volume": "4",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": [
                    "10.1371/journal.pone.0008407"
                ]
            }
        },
        "BIBREF2": {
            "title": "ALLPATHS: De novo assembly of whole genome shotgun microreads",
            "authors": [],
            "year": 2008,
            "venue": "Genome Research",
            "volume": "18",
            "issn": "",
            "pages": "810-820",
            "other_ids": {
                "DOI": [
                    "10.1101/gr.7337908"
                ]
            }
        },
        "BIBREF3": {
            "title": "ALLPATHS 2: Small genomes assembled accurately and with high continuity from short paired reads",
            "authors": [],
            "year": 2009,
            "venue": "Genome Biology",
            "volume": "10",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": [
                    "10.1186/gb-2009-10-10-r103"
                ]
            }
        },
        "BIBREF4": {
            "title": "ABySS: a parallel assembler for short read sequence data",
            "authors": [],
            "year": 2009,
            "venue": "Genome Research",
            "volume": "19",
            "issn": "",
            "pages": "1117-1123",
            "other_ids": {
                "DOI": [
                    "10.1101/gr.089532.108"
                ]
            }
        },
        "BIBREF5": {
            "title": "De novo assembly of human genomes with massively parallel short read sequencing",
            "authors": [],
            "year": 2010,
            "venue": "Genome Research",
            "volume": "20",
            "issn": "",
            "pages": "265-272",
            "other_ids": {
                "DOI": [
                    "10.1101/gr.097261.109"
                ]
            }
        },
        "BIBREF6": {
            "title": "QSRA \u2013 a quality-value guided de novo short read assembler",
            "authors": [],
            "year": 2009,
            "venue": "BMC Bioinformatics",
            "volume": "10",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": [
                    "10.1186/1471-2105-10-69"
                ]
            }
        },
        "BIBREF7": {
            "title": "Minimus: a fast, lightweight genome assembler",
            "authors": [],
            "year": 2007,
            "venue": "BMC Bioinformatics",
            "volume": "8",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": [
                    "10.1186/1471-2105-8-64"
                ]
            }
        },
        "BIBREF8": {
            "title": "Genome Sequence Assembly Using Trace Signals and Additional Sequence Information Computer Science and Biology",
            "authors": [],
            "year": 1999,
            "venue": "Proceedings of the German Conference on Bioinformatics",
            "volume": "99",
            "issn": "",
            "pages": "45-56",
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF9": {
            "title": "Maximum likelihood genome assembly",
            "authors": [],
            "year": 2009,
            "venue": "Journal of Computational Biology",
            "volume": "16",
            "issn": "",
            "pages": "1-16",
            "other_ids": {
                "DOI": [
                    "10.1089/cmb.2008.0137"
                ]
            }
        },
        "BIBREF10": {
            "title": "CAP3: A DNA sequence assembly program",
            "authors": [],
            "year": 1999,
            "venue": "Genome Research",
            "volume": "9",
            "issn": "",
            "pages": "868-877",
            "other_ids": {
                "DOI": [
                    "10.1101/gr.9.9.868"
                ]
            }
        },
        "BIBREF11": {
            "title": "PCAP: A whole-genome assembly program",
            "authors": [],
            "year": 2003,
            "venue": "Genome Research",
            "volume": "13",
            "issn": "",
            "pages": "2164-2170",
            "other_ids": {
                "DOI": [
                    "10.1101/gr.1390403"
                ]
            }
        },
        "BIBREF12": {
            "title": "The fragment assembly string graph",
            "authors": [],
            "year": 2005,
            "venue": "Bioinformatics",
            "volume": "21",
            "issn": "",
            "pages": "ii79-ii85",
            "other_ids": {
                "DOI": [
                    "10.1093/bioinformatics/bti1114"
                ]
            }
        },
        "BIBREF13": {
            "title": "Using the miraEST assembler for reliable and automated mrna transcript assembly and snp detection in sequenced ests",
            "authors": [],
            "year": 2004,
            "venue": "Genome Research",
            "volume": "14",
            "issn": "",
            "pages": "1147-1159",
            "other_ids": {
                "DOI": [
                    "10.1101/gr.1917404"
                ]
            }
        },
        "BIBREF14": {
            "title": "An Eulerian path approach to DNA fragment assembly",
            "authors": [],
            "year": 2001,
            "venue": "Proc Natl Acad Sci",
            "volume": "98",
            "issn": "",
            "pages": "9748-9753",
            "other_ids": {
                "DOI": [
                    "10.1073/pnas.171285098"
                ]
            }
        },
        "BIBREF15": {
            "title": "Assembling millions of short DNA sequences using SSAKE",
            "authors": [],
            "year": 2007,
            "venue": "Bioinformatics",
            "volume": "23",
            "issn": "",
            "pages": "500-501",
            "other_ids": {
                "DOI": [
                    "10.1093/bioinformatics/btl629"
                ]
            }
        },
        "BIBREF16": {
            "title": "Short read fragment assembly of bacterial genomes",
            "authors": [],
            "year": 2008,
            "venue": "Genome Research",
            "volume": "18",
            "issn": "",
            "pages": "324-330",
            "other_ids": {
                "DOI": [
                    "10.1101/gr.7088808"
                ]
            }
        },
        "BIBREF17": {
            "title": "Velvet: algorithms for de novo short read assembly using de Bruijn graphs",
            "authors": [],
            "year": 2008,
            "venue": "Genome Research",
            "volume": "18",
            "issn": "",
            "pages": "821-829",
            "other_ids": {
                "DOI": [
                    "10.1101/gr.074492.107"
                ]
            }
        }
    }
}
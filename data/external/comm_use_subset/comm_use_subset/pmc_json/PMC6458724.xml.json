{
    "paper_id": "PMC6458724",
    "metadata": {
        "title": "An OpenMP-based tool for finding longest common subsequence in bioinformatics",
        "authors": [
            {
                "first": "Rayhan",
                "middle": [],
                "last": "Shikder",
                "suffix": "",
                "email": "shikderr@myumanitoba.ca",
                "affiliation": {}
            },
            {
                "first": "Parimala",
                "middle": [],
                "last": "Thulasiraman",
                "suffix": "",
                "email": "thulasir@cs.umanitoba.ca",
                "affiliation": {}
            },
            {
                "first": "Pourang",
                "middle": [],
                "last": "Irani",
                "suffix": "",
                "email": "pourang.irani@umanitoba.ca",
                "affiliation": {}
            },
            {
                "first": "Pingzhao",
                "middle": [],
                "last": "Hu",
                "suffix": "",
                "email": "pingzhao.hu@umanitoba.ca",
                "affiliation": {}
            }
        ]
    },
    "body_text": [
        {
            "text": "Finding Longest Common Subsequence (LCS) is a classic problem in the field of computer algorithms and has diversified application domains. A subsequence of a string is another string which can be derived from the original string by deleting none or few characters (contiguous or non-contiguous) from the original string. A longest common subsequence of two given strings is a string which is the longest string that is a subsequence of both the strings. The sequential version of the LCS algorithm using \u201cequal-unequal\u201d comparisons takes \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\varOmega \\left( {\\text{mn}} \\right)$$\\end{document}\u03a9mn time, where m and n represent the length of the two sequences being compared [1, 2]. It is necessary to mention that the problem of finding the LCS of more than two strings is NP-hard in nature [3, 4].",
            "cite_spans": [
                {
                    "start": 941,
                    "end": 942,
                    "mention": "1",
                    "ref_id": "BIBREF0"
                },
                {
                    "start": 944,
                    "end": 945,
                    "mention": "2",
                    "ref_id": "BIBREF11"
                },
                {
                    "start": 1058,
                    "end": 1059,
                    "mention": "3",
                    "ref_id": "BIBREF12"
                },
                {
                    "start": 1061,
                    "end": 1062,
                    "mention": "4",
                    "ref_id": "BIBREF13"
                }
            ],
            "section": "Introduction",
            "ref_spans": []
        },
        {
            "text": "LCS has various applications in multiple fields including DNA sequence alignment in bioinformatics [5\u20137], speech and image recognition [8, 9], file comparison, optimization of database query etc. [10]. In the field of bioinformatics, pattern discovery helps to discover common patterns among DNA sequences of interest which might suggest that they have biological relation among themselves (e.g., similar biological functions) [11]. In discovering patterns between sequences, LCS plays an important role to find the longest common region between two sequences. Although a praiseworthy amount of efforts have been made in the task of pattern discovery, with the increase of sequence lengths, algorithms seemingly face performance bottlenecks [12]. Furthermore, with the advent of next-generation sequencing technologies, sequence data is increasing rapidly [13], which demands algorithms with minimum possible execution time. Parallel algorithms can play a vital role in this regard.",
            "cite_spans": [
                {
                    "start": 100,
                    "end": 101,
                    "mention": "5",
                    "ref_id": "BIBREF14"
                },
                {
                    "start": 102,
                    "end": 103,
                    "mention": "7",
                    "ref_id": "BIBREF16"
                },
                {
                    "start": 136,
                    "end": 137,
                    "mention": "8",
                    "ref_id": "BIBREF17"
                },
                {
                    "start": 139,
                    "end": 140,
                    "mention": "9",
                    "ref_id": "BIBREF18"
                },
                {
                    "start": 197,
                    "end": 199,
                    "mention": "10",
                    "ref_id": "BIBREF1"
                },
                {
                    "start": 428,
                    "end": 430,
                    "mention": "11",
                    "ref_id": "BIBREF2"
                },
                {
                    "start": 742,
                    "end": 744,
                    "mention": "12",
                    "ref_id": "BIBREF3"
                },
                {
                    "start": 857,
                    "end": 859,
                    "mention": "13",
                    "ref_id": "BIBREF4"
                }
            ],
            "section": "Introduction",
            "ref_spans": []
        },
        {
            "text": "Out of the parallel solutions of the LCS problem, anti-diagonal [14] and bit-parallel [15] algorithms are few of the firsts and noteworthy attempts. Recently, with the rise of Graphics Processing Unit (GPU)-based accelerators, several Compute Unified Device Architecture (CUDA)-based GPU targeted solutions to the LCS problem have been proposed. Yang et al. [16] are one of the firsts to propose an improved row-wise independent parallel version of the LCS algorithm by changing the data dependency used by a dynamic programming approach and using unique memory-access properties of GPUs. More recently, Li et al. [17] have proposed a parallel formulation of the anti-diagonal approach to the LCS algorithm using a GPU-based model. Although these GPU-based models offer faster execution times, GPU devices are still quite expensive in nature, hence only few computers are equipped with GPUs. In such cases, to achieve performance improvement, CPU-based parallel LCS algorithms (e.g. message passing interface (MPI) and open multi-processing (OpenMP)) are still greatly demanded. However, to the best of our knowledge, there is no such publicly available CPU-based tool for the end users. We addressed this gap by developing a new OpenMP-based tool for the end users by improving the row-wise independent version [16] of the LCS algorithm. Moreover, we also developed two other CPU-based parallel implementations (MPI, hybrid MPI-OpenMP) of the algorithm and provided a detailed benchmarking of all these implementations on simulated and real DNA sequence data, which was absent for this version of the LCS algorithm. The main contributions of this study are listed below.A new OpenMP-based publicly available tool for finding length of LCS of DNA sequences for the end users.A detailed benchmarking of the newly developed CPU-based parallel algorithms using different performance metrics on both simulated and real DNA sequence data, where we found that our OpenMP-based algorithm provides at-least 2 times absolute speedup (compared to the best sequential version) and 7 times relative speedup (compared to using only 1 thread).A comparison of the newly developed OpenMP-based LCS algorithm with and without branch conditions.\n",
            "cite_spans": [
                {
                    "start": 65,
                    "end": 67,
                    "mention": "14",
                    "ref_id": "BIBREF5"
                },
                {
                    "start": 87,
                    "end": 89,
                    "mention": "15",
                    "ref_id": "BIBREF6"
                },
                {
                    "start": 359,
                    "end": 361,
                    "mention": "16",
                    "ref_id": "BIBREF7"
                },
                {
                    "start": 615,
                    "end": 617,
                    "mention": "17",
                    "ref_id": "BIBREF8"
                },
                {
                    "start": 1313,
                    "end": 1315,
                    "mention": "16",
                    "ref_id": "BIBREF7"
                }
            ],
            "section": "Introduction",
            "ref_spans": []
        },
        {
            "text": "Yang et al. [16] has devised a row-wise independent parallel algorithm by removing dependency among the cells of the same row. The modified equation is as follows:2\\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$R\\left[ {i,j} \\right]\\, = \\,\\left\\{ \\begin{array}{*{20}{ll}} 0\\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\;\\; if\\,i = 0 \\, or\\, j = 0 \\\\ R\\left[ {i - 1,j - 1} \\right] + 1\\qquad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\;\\; if\\,A\\left[ i \\right] = B\\left[ j \\right] \\\\ { \\text{max} }\\left( {R\\left[ {i - 1,j} \\right],R\\left[ {i - 1,j - k - 1} \\right] + 1} \\right)\\quad \\;\\, if\\,A = B\\left[ {j - k} \\right] \\\\ { \\text{max} }\\left( {R\\left[ {i - 1,j} \\right],0} \\right)\\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad if\\,j - k = 0 \\\\ \\end{array} \\right.$$\\end{document}Ri,j=0ifi=0orj=0Ri-1,j-1+1ifAi=BjmaxRi-1,j,Ri-1,j-k-1+1ifA=Bj-kmaxRi-1,j,0ifj-k=0\n",
            "cite_spans": [
                {
                    "start": 13,
                    "end": 15,
                    "mention": "16",
                    "ref_id": "BIBREF7"
                }
            ],
            "section": "Row-wise independent algorithm (Version 1) ::: Preliminaries ::: Main text",
            "ref_spans": []
        },
        {
            "text": "Here, \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$k$$\\end{document}k denotes the number of steps required to find either a match, such as \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$${\\text{A}}\\left[ {\\text{i}} \\right] = {\\text{B}}\\left[ {{\\text{j}} - {\\text{k}}} \\right]$$\\end{document}Ai=Bj-k or \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$${\\text{j}} - {\\text{k}} = 0$$\\end{document}j-k=0. Yang et al. [16] has divided their algorithm into two steps. First, they calculated the values of \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$${\\text{j}} - {\\text{k }}$$\\end{document}j-k for every \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$i$$\\end{document}i and stored these values in another table named P. The equation to calculate the value of \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$P$$\\end{document}P is given below.3\\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$P\\left[ {i,j} \\right]\\, = \\,\\left\\{ \\begin{array}{l} 0\\quad \\quad \\quad \\quad \\quad if \\, j = 0 \\hfill \\\\ j - 1\\quad \\quad \\quad \\;\\;if\\, B\\left[ {j - 1} \\right] = C\\left[ i \\right] \\hfill \\\\ P\\left[ {i,j - 1} \\right]\\quad \\;\\,otherwise \\hfill \\\\ \\end{array} \\right.$$\\end{document}Pi,j=0ifj=0j-1ifBj-1=CiPi,j-1otherwise\n",
            "cite_spans": [
                {
                    "start": 1079,
                    "end": 1081,
                    "mention": "16",
                    "ref_id": "BIBREF7"
                }
            ],
            "section": "Row-wise independent algorithm (Version 1) ::: Preliminaries ::: Main text",
            "ref_spans": []
        },
        {
            "text": "Here, \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$C$$\\end{document}C is the string comprised of the unique characters of string \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$A$$\\end{document}A and string \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$B$$\\end{document}B. After that the value of score table \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$R$$\\end{document}R were calculated using the following updated equation.4\\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$R\\left[ {i,\\,j} \\right] = \\left\\{ {\\begin{array}{*{20}ll} 0 & {if\\,i = 0\\,or\\,j = 0} \\\\ {R\\left[ {i - 1,\\,j - 1} \\right] + 1} & {if\\,A\\left[ i \\right] = B\\left[ j \\right]} \\\\ {\\max \\left( {R\\left[ {i - 1,\\,j} \\right],R\\left[ {i - 1,\\,j - k - 1} \\right] + 1} \\right)} & {if\\,A = B\\left[ {j - k} \\right]} \\\\ {\\max \\left( {R\\left[ {i - 1,\\,j} \\right],0} \\right)} & {if\\,j - k = 0} \\\\ \\end{array} } \\right.$$\\end{document}Ri,j=0ifi=0orj=0Ri-1,j-1+1ifAi=BjmaxRi-1,j,Ri-1,j-k-1+1ifA=Bj-kmaxRi-1,j,0ifj-k=0\n",
            "cite_spans": [],
            "section": "Row-wise independent algorithm (Version 1) ::: Preliminaries ::: Main text",
            "ref_spans": []
        },
        {
            "text": "Here, c denotes the index of character \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$A\\left[ {i - 1} \\right]$$\\end{document}Ai-1 in string \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$C$$\\end{document}C.",
            "cite_spans": [],
            "section": "Row-wise independent algorithm (Version 1) ::: Preliminaries ::: Main text",
            "ref_spans": []
        },
        {
            "text": "As branching can hamper the performance of parallel algorithms, Yang et al. [16] further modified the calculation of \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$P$$\\end{document}P matrix using the following equation.5\\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$P\\left[ {i,j} \\right] = \\left\\{ \\begin{array}{l} 0\\quad \\quad \\quad \\quad \\quad \\quad if \\, j = 0 \\hfill \\\\ j\\quad \\quad \\quad \\quad \\quad \\quad if\\, B\\left[ {j - 1} \\right] = C\\left[ i \\right] \\hfill \\\\ P\\left[ {i,j - 1} \\right]\\quad \\quad \\;otherwise \\hfill \\\\ \\end{array} \\right.$$\\end{document}Pi,j=0ifj=0jifBj-1=CiPi,j-1otherwise\n",
            "cite_spans": [
                {
                    "start": 77,
                    "end": 79,
                    "mention": "16",
                    "ref_id": "BIBREF7"
                }
            ],
            "section": "Row-wise Independent Algorithm (Version 2) ::: Preliminaries ::: Main text",
            "ref_spans": []
        },
        {
            "text": "Then Eq. (4) can be rewritten as follows with one branching condition reduced.6\\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$R\\left[ {i,j} \\right] = ~\\left\\{ {\\begin{array}{*{20}{l}} 0\\\\ {\\max \\left( {R\\left[ {i - 1,j} \\right],0} \\right)}\\\\ {\\max (R\\left[ {i - 1,j} \\right],~R\\left[ {i - 1,P\\left[ {c,j} \\right] - 1} \\right] + 1)} \\end{array}\\begin{array}{*{20}{l}} {if~i = 0~or~j = 0}\\\\ {if~P\\left[ {c,j} \\right] = 0}\\\\ {otherwise} \\end{array}} \\right.$$\\end{document}Ri,j=0maxRi-1,j,0max(Ri-1,j,Ri-1,Pc,j-1+1)ifi=0orj=0ifPc,j=0otherwise\n",
            "cite_spans": [],
            "section": "Row-wise Independent Algorithm (Version 2) ::: Preliminaries ::: Main text",
            "ref_spans": []
        },
        {
            "text": "From the two versions of row-wise independent algorithms, we can see that the calculation of values of table P only depends on the same row. In contrast, the calculation of the values of score table R depends on the previous row only.",
            "cite_spans": [],
            "section": "Row-wise Independent Algorithm (Version 2) ::: Preliminaries ::: Main text",
            "ref_spans": []
        },
        {
            "text": "For the calculation of the P table, each row is independent and can be calculated in a parallel way. Therefore, in our MPI implementation, we scattered the P table to all the processes in the beginning. After calculating the corresponding chunk values, process number zero gathers the partial results from all the other processes. For the calculation of score table R, elements in each row can be scattered among the processes and gathered afterwards. This scatter and gather operations need to be done for every row. Hence, the communication and synchronization overheads are expected to be higher for the MPI implementation approach.",
            "cite_spans": [],
            "section": "Methodology ::: Main text",
            "ref_spans": []
        },
        {
            "text": "A shared memory implementation can largely mitigate the communication and synchronization overheads of distributed memory implementations which inspired us to develop the shared memory (OpenMP) implementation. In case of the OpenMP implementation, we used work-sharing construct #pragma omp parallel for (an OpenMP directive for sharing iterations of a loop among the available threads) to compute the elements of a single row of the score table R in parallel. We tried different scheduling strategies (static, dynamic, and guided) for sharing works among the threads. The calculation of the P table was also shared among threads. This time, the outer loop was parallelized using #pragma omp parallel for construct, as every row is independent of each other.",
            "cite_spans": [],
            "section": "Methodology ::: Main text",
            "ref_spans": []
        },
        {
            "text": "In the hybrid MPI-OpenMP approach, we selected the optimum number of processes and threads from the experiments of MPI and OpenMP approach. After that we scattered every row among processes and inside a single process we further shared the chunk of rows among threads using #pragma omp parallel for. To account for longer DNA sequences, we optimized the space complexity of all the three implementations where we kept only the current and the previous row of the score table.",
            "cite_spans": [],
            "section": "Methodology ::: Main text",
            "ref_spans": []
        },
        {
            "text": "We used two different data sets for our experiments. First one is a simulated DNA sequence data, collected from University of California Riverside\u2019s (UCR) random DNA sequence generator [18]. The lengths of the different pairs of sequences are between 128 base pairs to 32,768 base pairs. The second data set consists of 8 virus genome sequence pairs and two entire chromosome genome sequence pairs of two eukaryotes, collected from the website of National Center for Biotechnology Information (NCBI) [19]. The selected sequence lengths vary from 359 base pairs to 32,276 base pairs for the viruses, and from 15,05,371 base pairs to 1,61,99,981 base pairs for the eukaryotes. Table 1 represents the selected virus and eukaryote pairs and their sequence lengths.\n",
            "cite_spans": [
                {
                    "start": 186,
                    "end": 188,
                    "mention": "18",
                    "ref_id": "BIBREF9"
                },
                {
                    "start": 501,
                    "end": 503,
                    "mention": "19",
                    "ref_id": "BIBREF10"
                }
            ],
            "section": "Data sets and specifications of the computer ::: Results and discussion ::: Main text",
            "ref_spans": [
                {
                    "start": 681,
                    "end": 682,
                    "mention": "1",
                    "ref_id": "TABREF0"
                }
            ]
        },
        {
            "text": "All the experiments were run on University of Manitoba\u2019s on-campus cluster computing system (Mercury machine). The cluster consists of four fully connected computing nodes with 2-gigabit ethernet lines between every pair of nodes. Each node consists of two 14-core Intel Xeon E5-2680 v4 2.40 GHz CPUs with 128 GB of RAM. Having a total of 28 cores inside, with the help of hyper-threading, each node is capable of running twice as many hardware threads (56 threads) at a time.",
            "cite_spans": [],
            "section": "Data sets and specifications of the computer ::: Results and discussion ::: Main text",
            "ref_spans": []
        },
        {
            "text": "For the MPI approach, we tuned for the number of processes and found that using 4 process gives better relative speedup. For the OpenMP approach, we tuned for the number of threads and the scheduling strategy (static, dynamic, and guided). We found that using 16 threads and a static scheduling of work sharing among the threads provided 7 times relative speedup (see Fig. 1a, b). Finally, for the hybrid MPI-OpenMP approach, we used 4 processes (or nodes) and 16 threads.\n",
            "cite_spans": [],
            "section": "Comparison among different approaches ::: Results and discussion ::: Main text",
            "ref_spans": [
                {
                    "start": 373,
                    "end": 374,
                    "mention": "1",
                    "ref_id": "FIGREF0"
                }
            ]
        },
        {
            "text": "For comparison purpose, we experimented with a varying number of sequence lengths. Figure 2a, illustrates the execution times for different implementations where we can see that our OpenMP implementation outperforms all the other approaches and is almost 2 times faster than the best sequential version. However, the MPI approach provides poor results due to the increased amount of communication and synchronization overhead caused by m scatter and gather operations (blocking in nature). The hybrid MPI-OpenMP approach performs the worst. As in the hybrid approach, the number of scatter and gather operations is the same as the MPI approach, and it also adds synchronization overheads of the OpenMP, and therefore this implementation provides the worst result. This observation indicates that distributed memory implementation is discouraged for the LCS algorithm. In order to validate our results, we also experimented with the real-DNA sequence data (see Table 1). From Fig. 2b, we can see that even for the real data the OpenMP implementation is having at-least 2 times speedup from the best sequential version. For longer DNA sequences (SP 9, SP 10 in Fig. 2b), the OpenMP speedups are even higher, whereas the MPI and the hybrid implementations took more than a week to complete.\n",
            "cite_spans": [],
            "section": "Comparison among different approaches ::: Results and discussion ::: Main text",
            "ref_spans": [
                {
                    "start": 90,
                    "end": 91,
                    "mention": "2",
                    "ref_id": "FIGREF1"
                },
                {
                    "start": 980,
                    "end": 981,
                    "mention": "2",
                    "ref_id": "FIGREF1"
                },
                {
                    "start": 1164,
                    "end": 1165,
                    "mention": "2",
                    "ref_id": "FIGREF1"
                },
                {
                    "start": 966,
                    "end": 967,
                    "mention": "1",
                    "ref_id": "TABREF0"
                }
            ]
        },
        {
            "text": "In the above experiments, we used version 2 (without branching) of the row-wise independent algorithm. In order to compare the execution times of the two versions (version 1 and version 2), we also developed the version 1. Figure 2c illustrates the execution times for the two versions with varying sequence sizes and 1 thread only where we can see that version 1 performs relatively better than version 2 of the algorithm. Although version 2 has removed branching conditions, it has added more computations which might be the reason for its relatively bad execution times. Furthermore, CPU architectures are much better at branch predictions than GPUs. Therefore, the second version of the row-wise independent parallel algorithm performed well on GPUs [16] but not on CPUs.",
            "cite_spans": [
                {
                    "start": 755,
                    "end": 757,
                    "mention": "16",
                    "ref_id": "BIBREF7"
                }
            ],
            "section": "Comparison between the two versions of the algorithm in OpenMP approach ::: Results and discussion ::: Main text",
            "ref_spans": [
                {
                    "start": 230,
                    "end": 231,
                    "mention": "2",
                    "ref_id": "FIGREF1"
                }
            ]
        },
        {
            "text": "\nProject name:LCS row parallel (CPU)Project home page:\nhttps://github.com/RayhanShikder/lcs_parallel\nOperating systems:Platform independentProgramming language:COther requirements:gcc 4.8.5 or later, OpenMPI version 1.10.7 or later, OpenMP version 3.1 or laterLicense:MIT LicenseAny restrictions to use by non-academics:None.\n",
            "cite_spans": [],
            "section": "Availability and requirements ::: Limitations",
            "ref_spans": []
        }
    ],
    "ref_entries": {
        "TABREF0": {
            "text": "Table\u00a01: Information of real DNA sequence data sets collected from NCBI [19]\nbp stands for the number base pairs",
            "type": "table"
        },
        "FIGREF0": {
            "text": "Fig.\u00a01: Tuning number of threads and chunk sizes of OpenMP using simulated data. a Relative speedup with different number of threads. b Execution times (in seconds) for different scheduling strategies and chunk sizes. Number of threads was 16. Sequence lengths were set to 32,768 for both cases",
            "type": "figure"
        },
        "FIGREF1": {
            "text": "Fig.\u00a02: Performance evaluation using both simulated and real data. a Execution times for different implementations with varying sequence lengths for the simulated dataset. b Execution times for different implementations with different real DNA sequences. Here \u201cSP\u201d stands for sequence pairs from Table 1. The primary (left side) y-axis (execution times in seconds) describes the timing of sequence pairs SP 1 to SP 8 for virus, the secondary (right side) y-axis (execution times in hours) describes the timings of SP 9 and SP 10 for Eukaryotes. Points marked by cross signs denote that those experiments took more than 7 days to complete. c Execution times for different lengths of sequence strings from sequential implementation of the two versions of the row-wise independent algorithm",
            "type": "figure"
        }
    },
    "back_matter": [],
    "bib_entries": {
        "BIBREF0": {
            "title": "Bounds on the complexity of the longest common subsequence problem",
            "authors": [
                {
                    "first": "JD",
                    "middle": [],
                    "last": "Ullman",
                    "suffix": ""
                },
                {
                    "first": "AV",
                    "middle": [],
                    "last": "Aho",
                    "suffix": ""
                },
                {
                    "first": "DS",
                    "middle": [],
                    "last": "Hirschberg",
                    "suffix": ""
                }
            ],
            "year": 1976,
            "venue": "J ACM",
            "volume": "23",
            "issn": "",
            "pages": "1-12",
            "other_ids": {
                "DOI": [
                    "10.1145/321921.321922"
                ]
            }
        },
        "BIBREF1": {
            "title": "An overview of sequence comparison: time warps, string edits, and macromolecules",
            "authors": [
                {
                    "first": "JB",
                    "middle": [],
                    "last": "Kruskal",
                    "suffix": ""
                }
            ],
            "year": 1983,
            "venue": "SIAM Rev.",
            "volume": "25",
            "issn": "2",
            "pages": "201-237",
            "other_ids": {
                "DOI": [
                    "10.1137/1025045"
                ]
            }
        },
        "BIBREF2": {
            "title": "Analysis of the relationships among longest common subsequences, shortest common supersequences and patterns and its application on pattern discovery in biological sequences",
            "authors": [
                {
                    "first": "K",
                    "middle": [],
                    "last": "Ning",
                    "suffix": ""
                },
                {
                    "first": "HK",
                    "middle": [],
                    "last": "Ng",
                    "suffix": ""
                },
                {
                    "first": "HW",
                    "middle": [],
                    "last": "Leong",
                    "suffix": ""
                }
            ],
            "year": 2011,
            "venue": "Int J Data Min Bioinform.",
            "volume": "5",
            "issn": "",
            "pages": "611-625",
            "other_ids": {
                "DOI": [
                    "10.1504/IJDMB.2011.045413"
                ]
            }
        },
        "BIBREF3": {
            "title": "Limitations and potentials of current motif discovery algorithms",
            "authors": [
                {
                    "first": "J",
                    "middle": [],
                    "last": "Hu",
                    "suffix": ""
                },
                {
                    "first": "B",
                    "middle": [],
                    "last": "Li",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [],
                    "last": "Kihara",
                    "suffix": ""
                }
            ],
            "year": 2005,
            "venue": "Nucleic Acids Res",
            "volume": "33",
            "issn": "",
            "pages": "4899-4913",
            "other_ids": {
                "DOI": [
                    "10.1093/nar/gki791"
                ]
            }
        },
        "BIBREF4": {
            "title": "Big data: astronomical or genomical?",
            "authors": [
                {
                    "first": "ZD",
                    "middle": [],
                    "last": "Stephens",
                    "suffix": ""
                },
                {
                    "first": "SY",
                    "middle": [],
                    "last": "Lee",
                    "suffix": ""
                },
                {
                    "first": "F",
                    "middle": [],
                    "last": "Faghri",
                    "suffix": ""
                },
                {
                    "first": "RH",
                    "middle": [],
                    "last": "Campbell",
                    "suffix": ""
                },
                {
                    "first": "C",
                    "middle": [],
                    "last": "Zhai",
                    "suffix": ""
                },
                {
                    "first": "MJ",
                    "middle": [],
                    "last": "Efron",
                    "suffix": ""
                }
            ],
            "year": 2015,
            "venue": "PLoS Biol",
            "volume": "13",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": [
                    "10.1371/journal.pbio.1002195"
                ]
            }
        },
        "BIBREF5": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF6": {
            "title": "A fast and practical bit-vector algorithm for the longest common subsequence problem",
            "authors": [
                {
                    "first": "M",
                    "middle": [],
                    "last": "Crochemore",
                    "suffix": ""
                },
                {
                    "first": "CS",
                    "middle": [],
                    "last": "Iliopoulos",
                    "suffix": ""
                },
                {
                    "first": "YJ",
                    "middle": [],
                    "last": "Pinzon",
                    "suffix": ""
                },
                {
                    "first": "JF",
                    "middle": [],
                    "last": "Reid",
                    "suffix": ""
                }
            ],
            "year": 2001,
            "venue": "Inf Process Lett.",
            "volume": "80",
            "issn": "",
            "pages": "279-285",
            "other_ids": {
                "DOI": [
                    "10.1016/S0020-0190(01)00182-X"
                ]
            }
        },
        "BIBREF7": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF8": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF9": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF10": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF11": {
            "title": "The string-to-string correction problem",
            "authors": [
                {
                    "first": "RA",
                    "middle": [],
                    "last": "Wagner",
                    "suffix": ""
                },
                {
                    "first": "MJ",
                    "middle": [],
                    "last": "Fischer",
                    "suffix": ""
                }
            ],
            "year": 1974,
            "venue": "J ACM.",
            "volume": "21",
            "issn": "",
            "pages": "168-173",
            "other_ids": {
                "DOI": [
                    "10.1145/321796.321811"
                ]
            }
        },
        "BIBREF12": {
            "title": "The complexity of some problems on subsequences and supersequences",
            "authors": [
                {
                    "first": "D",
                    "middle": [],
                    "last": "Maier",
                    "suffix": ""
                }
            ],
            "year": 1978,
            "venue": "J ACM",
            "volume": "25",
            "issn": "",
            "pages": "322-336",
            "other_ids": {
                "DOI": [
                    "10.1145/322063.322075"
                ]
            }
        },
        "BIBREF13": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF14": {
            "title": "Fast longest common subsequences for bioinformatics dynamic programming",
            "authors": [
                {
                    "first": "M",
                    "middle": [],
                    "last": "Ossman",
                    "suffix": ""
                },
                {
                    "first": "LF",
                    "middle": [],
                    "last": "Hussein",
                    "suffix": ""
                }
            ],
            "year": 2012,
            "venue": "Population (Paris).",
            "volume": "5",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF15": {
            "title": "Improved tools for biological sequence comparison",
            "authors": [
                {
                    "first": "WR",
                    "middle": [],
                    "last": "Pearson",
                    "suffix": ""
                },
                {
                    "first": "DJ",
                    "middle": [],
                    "last": "Lipman",
                    "suffix": ""
                }
            ],
            "year": 1988,
            "venue": "Proc Natl Acad Sci",
            "volume": "85",
            "issn": "",
            "pages": "2444-2448",
            "other_ids": {
                "DOI": [
                    "10.1073/pnas.85.8.2444"
                ]
            }
        },
        "BIBREF16": {
            "title": "Basic local alignment search tool",
            "authors": [
                {
                    "first": "SF",
                    "middle": [],
                    "last": "Altschul",
                    "suffix": ""
                },
                {
                    "first": "W",
                    "middle": [],
                    "last": "Gish",
                    "suffix": ""
                },
                {
                    "first": "W",
                    "middle": [],
                    "last": "Miller",
                    "suffix": ""
                },
                {
                    "first": "EW",
                    "middle": [],
                    "last": "Myers",
                    "suffix": ""
                },
                {
                    "first": "DJ",
                    "middle": [],
                    "last": "Lipman",
                    "suffix": ""
                }
            ],
            "year": 1990,
            "venue": "J Mol Biol",
            "volume": "215",
            "issn": "",
            "pages": "403-410",
            "other_ids": {
                "DOI": [
                    "10.1016/S0022-2836(05)80360-2"
                ]
            }
        },
        "BIBREF17": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF18": {
            "title": "",
            "authors": [
                {
                    "first": "EGM",
                    "middle": [],
                    "last": "Petrakis",
                    "suffix": ""
                }
            ],
            "year": 1993,
            "venue": "Image representation, indexing and retrieval based on spatial relationships and properties of objects",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        }
    }
}
{"title": "Structural Complexity of DNA Sequence", "body": "DNA sequence analysis becomes important part in modern molecular biology. DNA sequence is composed of four nucleotide bases\u2014adenine (abbreviated A), cytosine (C), guanine (G), and thymine (T) in any order. With four different nucleotides, 2 nucleotides could only code for maximum of 42 amino acids, but 3 nucleotides could code for a maximum 43 amino acids. George Gamow was the first person to postulate that every three bases can translate to a single amino acid, called a codon. Marshall Nirenberg and Heinrich J. Matthaei were the first to elucidate the nature of a genetic code. A short DNA sequence can contain less genetic information, while lots of bases may contain much more genetic information, and any two nucleotides switch place may change the meaning of genetic messages.\n\nSequence arrangement can produce many different results, but only few codons exist in living bodies. Some sequences do not contain any information which is known as junk DNA. Finding an efficient way to analyze a sequence fragment corresponding to genetic functions is also a challenging problem.\n\nIn recent papers, methods broadly fall into two categories, sequence complexity [1, 2] and structural pattern analysis [3\u20138]. Koslicki [1] presented a method for computing sequence complexities. He redefined topological entropy function so that the complexity value will not converge toward zero for much longer sequences. With separate sequence into several segments, it can determine the segments where are exons or introns, and meaningful or meaningless. Hao et al. [7] given a graphical representation of DNA sequence, according to this paper, we can find some rare occurred subsequences. R. Zhang and C. T. Zhang [4] used four-nucleotide-related function drawing 3D curves graph to analyze the number of four-nucleotide occurrence probabilities. Liou et al. [9] had given a new idea in modeling complexity for music rhythms; this paper translated text messages into computable values, so computers can score for music rhythms.\n\nIn this paper, we propose a new method for calculating sequences different from other traditional methods. It holds not only statistical values but also structural information. We replace four nucleotides with tree structure presented in [9] and use mathematical tools to calculate complexity values of the sequences. So we can compare two sequences with values and determine dissimilarity between these two sequences. In biomedical section, we can use this technique to find the effective drugs for new virus with priority.\n\nFor computing complexity of our DNA tree, we need some rules for converting tree to another structure. We use a stack similarly structure to represent the hierarchy of DNA tree, called bracketed string. DNA tree can transfer to a unique bracketed string by the following symbols, and it can transfer back to the original tree:\nF: the current location of tree nodes; it can be replaced by any word or be omitted;+: the following string will express the right subtree;\u2212: the following string will express the left subtree;[: this symbol is pairing with ]; \u201c[\u22ef]\u201d denotes a subtree where \u201c\u22ef\u201d; indicates all the bracketed strings of its subtree;]: see [ description. \n\n\nFollowing the previous symbols, Figure 3 shows that nucleotide base A and T represented tree can transfer to [F[\u2212F][+F]] and [F[\u2212F][+F[\u2212F][+F]]], respectively.\n\nAnd Figure 4 is the bracketed string of Figure 2. We can see that when the tree grows, string seems to be more redundant. Since we focus here only on DNA trees, we can simplify the bracketed string representations. First, our trees have only two subtrees. Second, the \u201cF\u201d notation for the tree is trivial. With these two characteristics, we may omit the \u201cF\u201d notation from the bracketed string and use only four symbols, {[, ], \u2212, +}, to represent trees. In our cases, \u201c[\u22ef]\u201d denotes a subtree where \u201c\u22ef\u201d indicates all the bracketed strings of its subtrees. \u201c\u2212\u201d indicated the next \u201c[\u22ef]\u201d notation for a tree is a left subtree of current node, and \u201c+\u201d is a right subtree vice versa.  Figure 5 is the simplified string of bracketed string shown in Figure 4.\n\nWhen we obtain DNA tree and bracketed string representation, we need rewriting rules for analyzing tree structure. There are some types of rewriting mechanism such as Chomsky grammar and Lindenmayer system (L-system for short). The largest difference between two string rewriting mechanisms lies in the technique used to apply productions. Chomsky grammar is suitable for applying productions sequentially, while L-system is for parallel. In our structure, applying L-system to our representations is better than Chomsky grammar.\n\nThe L-system was introduced by the biologist Lindenmayer in 1968 [13]. The central concept of the L-system is rewriting. In general, rewriting is a technique used to define complex objects by successively replacing parts of a simple initial object, using a set of rewriting rules or productions. In the next section, we will present how we use L-system to our DNA tree. The L-system is defined as follows.\n\n\nDefinition 1L-system grammars are very similar to the Chomsky grammar, defined as a tuple [14]:\n(1)G=(V,\u03c9,P),\nwhere\nV = {s\n1, s\n2,\u2026, s\nn} is an alphabet,\n\u03c9 (start, axiom, or initiator) is a string of symbols from V defining the initial state of the system,\nP is defined by a production map P : V \u2192 V* with s \u2192 P(s) for each s in V. The identity production s \u2192 s is assumed. These symbols are called constants or terminals. \n\n\n\nAs discussed earlier, we want to generate the rules from DNA trees. In this section, we will explain how we apply rewriting rules to those trees. We can apply distinct variables to each node. Since the technique described previously always generates two subtrees for each node, for every nonterminal node, they always can be explained in the following format:\n(2)P\u2192LR,\nwhere P denotes the current node, L denotes its left subtree, and R denotes its right subtree, respectively. We give an example shown in Figure 6; left tree has three nodes and only root is nonterminal node, it can be rewritten as P \u2192 LR. Right tree has five nodes, root P with left subtree L and right subtree R. Left subtree is terminal, but right is not. R has two terminal subtrees R\nL and R\nR, so this tree can be rewritten as P \u2192 LR and R \u2192 R\nL\nR\nR.\n\nSimilarly, we can also use rewriting rules to generate bracketed strings. In rewriting rules for DNA trees shown in Section 2.3, we write P \u2192 LR for a tree with left and right subtrees. Note that we call L and R as the nonterminals. In this section, terminal nodes will be separated from trees, and we use \u201cnull\u201d to represent a terminal. Such tree will have a corresponding bracketed string as follows: [[\u2212F\u22ef][+F\u22ef]]. \u201c[\u2212F\u22ef]\u201d represents the left subtree, while \u201c[+F\u22ef]\u201d represents the right subtree. Therefore, we can replace the rewriting rules with\n(3)P\u2192[\u2212FL][+FR],F\u2192\u22ef,R\u2192\u22ef,\nwhere \u201c\u22ef\u201d is the rewriting rule for the bracketed string of each subtree. For the sake of readability, we replace the words such as \u201cR\nRL\u201d and \u201cR\nRR\u201d. In Figure 7, we show the rewriting rules for the bracketed string of the tree in Figure 3.\n\nAs we can see, there are \u201cnulls\" in the rules. Those \u201cnulls\u201d do not have significant effects to our algorithm, so we simply ignore the nulls. Now, Figure 3 can apply new rewriting rules without trivial nulls as Figure 8.\n\nWhen tree grows up, the rewriting rules may generate identical rules. Assume that we have the following rules:\n(4)P\u2192[\u2212FTL][+FTR],TL\u2192[\u2212F][+F],TR\u2192[\u2212F][+FTRR],TRR\u2192[\u2212F][+FTRRR],TRRR\u2192[\u2212F].\nThese rules can generate exactly one bracketed string and, thus, exactly one DNA tree. All these rules form a rule set that represents a unique DNA tree. When we look at T\nR \u2192 [\u2212F][+FT\nRR] and T\nRR \u2192 [\u2212F][+FT\nRRR], they have the same structure since they both have a right subtree and do not have a left subtree. The only difference is that one of the subtrees is T\nRR and that the other is T\nRRR. We will define two terms to express the similarity between two rewriting rules, and these terms can simplify complexity analysis.\n\nAt the end of the previous section, we discussed that T\nR \u2192 [\u2212F][+FT\nRR] and T\nRR \u2192 [\u2212F][+FT\nRRR] are almost the same. How can we summarize or organize an effective feature to them? Liou et al. [9] gave two definitions to classify similar rewriting rules described before as follows.\n\n\nDefinition 2Homomorphism in rewriting rules. We define that rewriting rule R\n1 and rewriting rule R\n2 are homomorphic to each other if and only if they have the same structure. \n\n\nIn detail, rewriting rule R\n1 and rewriting rule R\n2 in DNA trees both have subtrees in corresponding positions or both not. Ignoring all nonterminals, if rule R\n1 and rule R\n2 generate the same bracketed string, then they are homomorphic by definition.\n\n\nDefinition 3Isomorphism on level X in rewriting rules. Rewriting rule R\n1 and rewriting rule R\n2 are isomorphic on depth X if they are homomorphic and their nonterminals are relatively isomorphic on depth X \u2212 1. Isomorphic on level 0 indicates homomorphism. \n\n\nApplying to the bracketed string, we ignore all nonterminals in (4) as follows:\n(5)P\u2192[\u2212FTL][+FTR]\u2192[\u2212F][+F],TL\u2192[\u2212F][+F]\u2192[\u2212F][+F],TR\u2192[\u2212F][+FTRR]\u2192[\u2212F][+F],TRR\u2192[\u2212F][+FTRRR]\u2192[\u2212F][+F],TRRR\u2192[\u2212F]\u2192[\u2212F].\n\n\nWe find that P, T\nL, T\nR, and T\nRR are homomorphic to each other; they generate the same bracketed string, [\u2212F][+F]. But T\nRRR is not homomorphic to any of the other rules; its bracketed string is [\u2212F].\n\nLet us recall DNA tree example in Figure 2; we will use this figure as an example to clarify these definitions. Now we marked some nodes shown in Figure 9; there are tree rooted at A, B, C, and D, respectively, tree A, tree B, tree C, and tree D. Tree A is isomorphic to tree C on depth 0 to 3, but they are not isomorphic on depth 4. Tree B is isomorphic to tree C on depth from 0 to 2, but they are not isomorphic on depth 3. D is not isomorphic to any other trees, nor is it homomorphic to any other trees.\n\nAfter we define the similarity between rules by homomorphism and isomorphism, we can classify all the rules into different subsets, and every subset has the same similarity relation. Now we list all the rewriting rules of Figure 2 into Table 1 but ignore terminal rules such as \u201c\u2192 null\u201d and transfer rule's name to class name (or class number). For example, we can give terminal rewriting rule a class, \u201cC\n3\u2192 null\u201d, and a rule link to two terminals; we can give them \u201cC\n2 \u2192 C\n3\nC\n3\"; here C\n3 is the terminal class. After performing classification, we obtain not only a new rewriting rule set but also a context-free grammar, which can be converted to automata.\n\nIn Table 1, rules such as T\nRLLL \u2192 [\u2212F][+F], and T\nRRRLL \u2192 [\u2212F][+F] and T\nRLRLR \u2192 [\u2212F][+F] are isomorphic on depth 1 and assigned to Class 4. There are twenty such rules before classification, so we write \u201c(20)C\n4 \u2192 [\u2212F][+F]\u201d. Similar rules such as P \u2192 [\u2212FT\nL][+FT\nR], T\nRLLL \u2192 [\u2212F][+F], and T\nRRRR \u2192 [\u2212F][+FT\nRRRRR] are isomorphic on depth 0, and there are 47 such rules. They are all assigned to Class 1 by following a similar classification procedure. The classification of the all rules is listed in Table 2. Note that this section also presents a new way to convert a context-sensitive grammar to a context-free one.\n\nWhen we transfer the DNA sequence to the rewriting rules, and classify all those rules we attempt to explore the redundancy in the tree that will be the base for building the cognitive map [15]. We compute the complexity of the tree which those classified rules represent. We know that a classified rewriting rule set is also a context-free grammar, so there are some methods for computing complexity of rewriting rule as follows.\n\n\nDefinition 4Topological entropy of a context-free grammar. The topological entropy K\n0 of (context-free grammar) CFG can be evaluated by means of the following three procedures [16, 17].(1)For each variable V\ni with productions (in Greibach form),\n(6)Vi\u2192ti1Ui1,ti2Ui2,\u2026,tikiUiki,\nwhere {t\ni1, t\ni2,\u2026, t\niki} are terminals and {U\ni1, U\ni2,\u2026, U\niki} are nonterminals. The formal algebraic expression for each variable is\n(7)Vi=\u2211j=1kitijUij.\n(2)By replacing every terminal t\nij with an auxiliary variable z, one obtains the generating function\n(8)Vi(z)=\u2211n=1\u221eNi(n)zn,\nwhere N\ni(n) is the number of words of length n descending from V\ni.(3)Let N(n) be the largest one of N\ni(n), N(n) = max\u2061{N\ni(n), for all i}. The previous series converges when z < R = e\n\u2212K0. The topological entropy is given by the radius of convergence R as\n(9)K0=\u2212ln\u2061R.\n\n\n\n\nOur productions have some difference from the aforementioned definitions. First, our productions are written in Chomsky-reduced form instead of Greibach form. Second, DNA is finite sequence; it generates finite tree, but the previous formulas are applied on infinite sequences. For convenience in the DNA tree case, we rewrite the definition as follows [9].\n\n\nDefinition 5Topological entropy of context free grammar for DNA tree.(1)Assume that there are n classes of rules and that each class C\ni contains n\ni rules. Let V\ni \u2208 {C\n1, C\n2,\u2026, C\nn}, U\nij \u2208 {R\nij, i = 1,2,\u2026, n, j = 1,2,\u2026, n\ni}, and a\nijk \u2208 {x : x = 1,2,\u2026, n}, where each U\nij has the following form:\n(10)Ui1\u2192Vai11Vai12,Ui2\u2192Vai21Vai22,\u22ef\u2192\u22ef,Uini\u2192Vaini1Vaini2.\n(2)The generating function of V\ni, V\ni(z) has a new form as follows:\n(11)Vi(z)=\u2211p=1ninipzVaip1(z)Vaip2(z)\u2211q=1niniq.\nIf V\ni does not have any nonterminal variables, we set V\ni(z) = 1.(3)After formulating the generating function V\ni(z), we intend to find the largest value of z, z\nmax\u2061, at which V\n1(z\nmax\u2061) converges. Note that we use V\n1 to denote the rule for the root node of the DNA tree. After obtaining the largest value, z\nmax\u2061, of V\n1(z), we set R = z\nmax\u2061, the radius of convergence of V\n1(z). We define the complexity of the DNA tree as\n(12)K0=\u2212ln\u2061R.\n\n\n\n\nNow we can do some examples of computation procedure for the complexity. According to our definition, the given values for the class parameters are listed in Table 3. There are five classes, so we obtain the formulas for V\n5(z\u2032), V\n4(z\u2032), V\n3(z\u2032), V\n2(z\u2032), and V\n1(z\u2032) successively. They are\n(13)V5(z\u2032)=1(by definition),V4(z\u2032)=\u2211p=1n4n4pz\u2032Va4p1(z\u2032)Va4p2(z\u2032)\u2211q=1niniq   =z\u2032\u00d7(20\u00d7V5(z\u2032)\u00d7V5(z\u2032))20=z\u2032,V3(z\u2032)=\u2211p=1n3n3pz\u2032Va3p1(z\u2032)Va3p2(z\u2032)\u2211q=1niniq   =z\u2032\u00d7(4\u00d7V5(z\u2032)\u00d7V4(z\u2032))4=z\u20322,V2(z\u2032)=\u2211p=1n2n2pz\u2032Va2p1(z\u2032)Va2p2(z\u2032)\u2211q=1niniq   =z\u2032\u00d7(4\u00d7V4(z\u2032)\u00d7V5(z\u2032))4=z\u20322,V1(z\u2032)=\u2211p=1n1n1pz\u2032Va1p1(z\u2032)Va1p2(z\u2032)\u2211q=1niniq   =8z\u2032\u00d7V1(z\u2032)2+2(z\u2032)3\u00d7V1(z\u2032)19    +(2(z\u2032)5+2(z\u2032)4+5(z\u2032)3)19.\n\n\nRearranging the previous equation for V\n1(z\u2032), we obtain a quadratic for V\n1(z\u2032):\n(14)819(z\u2032)\u00d7V1(z\u2032)+(1\u2212219(z\u2032)3)\u00d7V1(z\u2032)  +119(2(z\u2032)5+2(z\u2032)4+5(z\u2032)3)=0.\n\n\nSolving V\n1(z\u2032), we obtain the formula\n(15)V1(z\u2032)=((z\u2032)24\u2212198z\u2032)\u00b1198z\u2032B2\u2212A,\nwhere\n(16)A=32361(2(z\u2032)6+2(z\u2032)5+5(z\u2032)4),B=1\u2212219(z\u2032)3.\n\n\nFinally, the radius of convergence, R, and complexity, K\n0 = \u2212ln\u2061R, can be obtained from this formula. But, computing the z\nmax\u2061 directly is difficult, so we use iterations and region tests to approximate the complexity; details are as follows.(1)Rewrite the generating function as\n(17)Vim(z\u2032)=\u2211p=1ninipz\u2032Vaip1m\u22121(z\u2032)Vaip2m\u22121(z\u2032)\u2211q=1niniq,Vi0(z\u2032)=1.\n(2)The value from V\ni\n0(z\u2032) to V\ni\nm(z\u2032). When V\ni\nm\u22121(z\u2032) = V\ni\nm(z\u2032) for all rules, we say that V\ni\nm(z\u2032) reach the convergence, but z\u2032 is not the z\nmax\u2061 we want. Here, we set m = 1000 for each iteration.(3)Now we can test whether V\ni(z\u2032) is convergent or divergent at a number z\u2032. We use binary search to test every real number between 0 and 1; in every test, when V\ni(z\u2032) converges, we set bigger z\u2032 next time, but when V\ni(z\u2032) diverges, we set smaller z\u2032 next time. Running more iterations will obtain more precise radius. \n\n\nNow we can apply our technique to Chinese word sequences. Togawa et al. [18] gave a complexity of Chinese words, but his study was based on the number of strokes, which is different from our method. Here we use Big5 encoding for our system. Since the number of Chinese words is larger than 10000, we cannot directly use words as alphabet, so we need some conversion. We read a Chinese word into four hexadecimal letters so that we can replace the sequence with tree representation and compute the complexity.\n\nWhen it comes to biomedical section, we can create virus comparison database. Once a new virus or prion has been found, it will be easy to select corresponding drugs at the first time, according to cross comparison with each other by complexity in the database. We focus on most important viruses in recent years, such as Escherichia coli O157:H7 (E. coli o157), Enterovirus 71 (EV71), Influenza A virus subtype H1N1 (H1N1), Influenza A virus subtype H5N1 (H5N1), and severe acute respiratory syndrome (SARS). In recent years, these viruses have a significant impact and threat on the human world. We test these viruses and prions listed in Table 4. Here we can see that all prion regions cannot be analyzed by Koslicki method, but we can do it.\n\nFinally, if any object can be written as a sequence, and there exists tree representation with alphabet of sequence, we can compute the complexity of the object.\n\nIn this paper, we give a method for computing complexity of DNA sequences. The traditional method focused on the statistical data or simply explored the structural complexity without value. In our method, we transform the DNA sequence to DNA tree with tree representations at first.\n\nThen we transform the tree to context-free grammar format, so that it can be classified. Finally, we use redefined generating function and find the complexity values. We give a not only statistical but also structural complexity for DNA sequences, and this technique can be used in many important applications."}
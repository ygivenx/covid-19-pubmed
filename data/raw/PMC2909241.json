{"title": "Inverse folding of RNA pseudoknot structures", "body": "Let us turn back the clock: three decades ago Waterman et al. [25], Nussinov et al. [11] and Kleitman et al. in [26] analyzed RNA secondary structures. Secondary structures are coarse grained RNA contact structures, see Figure 3.\n\nRNA secondary structures as well as RNA pseudoknot structures can be represented as diagrams, i.e. labeled graphs over the vertex set [n] = {1, ..., n} with vertex degrees \u2264 1, represented by drawing its vertices on a horizontal line and its arcs (i, j) (i < j), in the upper half-plane, see Figure 4 and Figure 1. Given an arc (i, j) we refer to (j - i) as its arc-length.\n\nHere, vertices and arcs correspond to the nucleotides A, G, U, C and Watson-Crick (A-U, G-C) and (U-G) base pairs, respectively.\n\nIn a diagram, two arcs (i1, j1) and (i2, j2) are called crossing if i1 <i2 <j1 <j2 holds. Accordingly, a k-crossing is a sequence of arcs (i1, j1), ..., (ik, jk) such that i1 <i2 < ... <ik <j1 <j2 < ... <jk. We call diagrams containing at most (k - 1)-crossings, k-noncrossing diagrams, see Figure 5.\n\nRNA secondary structures exhibit no crossings in their diagram representation, see Figure 3 and Figure 4, and are therefore 2-noncrossing diagrams satisfying some minimum arc-length condition. An RNA pseudoknot structure is therefore a k-noncrossing diagram for some k satisfying some minimum arc-length condition.\n\nA structure in which any stack has at least size \u03c3 is called \u03c3-canonical, where a stack of size \u03c3 is a sequence of \"parallel\" arcs of the form(1)\n\nA sequence of consecutive stacks, separated by unpaired nucleotides,  i.e. where\n\nis called a stem of length r, see Figure 6.\n\nAs a natural generalization of RNA secondary structures k-noncrossing RNA structures [27-29] were introduced. A k-noncrossing RNA structure of length n is k-noncrossing diagram over [n] without arcs of the form (i, i + 1). In the following we assume k = 3, i.e. in the diagram representation there are at most two mutually crossing arcs, a minimum arc-length of four and a minimum stack-size of three base pairs. The notion k-noncrossing stipulates that the complexity of a pseudoknot is related to the maximal number of mutually crossing bonds. Indeed, most natural RNA pseudoknots are 3-noncrossing [30].\n\nBefore considering an inverse folding algorithm into specific RNA structures one has to have at least some rationale as to why there exists one sequence realizing a given target as mfe-configuration. In fact this is, on the level of entire folding maps, guaranteed by the combinatorics of the target structures alone. It has been shown in [31], that the numbers of 3-noncrossing RNA pseudoknot structures, satisfying the biophysical constraints grows asymptotically as c3n-52.03n, where c3 >0 is some explicitly known constant. In view of the central limit theorems of [32], this fact implies the existence of extended (exponentially large) sets of sequences that all fold into one 3-noncrossing RNA pseudoknot structure, S. In other words, the combinatorics of 3-noncrossing RNA structures alone implies that there are many sequences mapping (folding) into a single structure. The set of all such sequences is called the neutral network of the structure S [33,34], see Figure 7. The term \"neutral network\" as opposed to \"neutral set\" stems from giant component results of random induced subgraphs of n-cubes. That is, neutral networks are typically connected in sequence space.\n\nBy construction, all the sequences contained in such a neutral network are all compatible with S. That is, at any two positions paired in S, we find two bases capable of forming a bond (A-U, U-A, G-C, C-G, G-U and U-G), see Figure 8. Let s' be a sequence derived via a point-mutation of s. If s' is again compatible with S, we call this mutation \"compatible\".\n\nLet C[S] denote the set of S-compatible sequences. The structure S motivates to consider a new adjacency relation within C[S]. Indeed, we may reorganize a sequence (s1, ..., sn) into the pair(2)\n\nwhere the uh denotes the unpaired nucleotides and the ph = (si, sj) denotes base pairs, respectively, see Figure 8. We can then view  and  as elements of the formal cubes  and  implying the new adjacency relation for elements of C[S].\n\nAccordingly, there are two types of compatible neighbors in the sequence space u- and p-neighbors: a u-neighbor has Hamming distance one and differs exactly by a point mutation at an unpaired position. Analogously a p-neighbor differs by a compensatory base pair-mutation, see Figure 9.\n\nNote, however, that a p-neighbor has either Hamming distance one (G-C \u21a6 G-U) or Hamming distance two (G-C \u21a6 C-G). We call a u- or a p-neighbor, y, a compatible neighbor. In light of the adjacency notion for the set of compatible sequences we call the set of all sequences folding into S the neutral network of S. By construction, the neutral network of S is contained in C[S]. If y is contained in the neutral network we refer to y as a neutral neighbor. This gives rise to consider the compatible and neutral distance of the two sequences, denoted by C(s, s') and N(s, s'). These are the minimum length of a C[S]-path and path in the neutral network between s and s', respectively. Note that since each neutral path is in particular a compatible path, the compatible distance is always smaller or equal than the neutral distance.\n\nIn this paper we study the inverse folding problem for RNA pseudoknot structures: for a given 3-noncrossing target structure S, we search for sequences from C[S], that have S as mfe configuration.\n\nCross is an ab initio folding algorithm that maps RNA sequences into 3-noncrossing RNA structures. It is guaranteed to search all 3-noncrossing, \u03c3-canonical structures and derives some (not necessarily unique), loop-based mfe-configuration. In the following we always assume \u03c3 \u2265 3. The input of Cross is an arbitrary RNA sequence s and an integer N. Its output is a list of N 3-noncrossing, \u03c3-canonical structures, the first of which being the mfe-structure for s. This list of N structures (C0, C1, ..., CN-1) is ordered by the free energy and the first list-element, the mfe-structure, is denoted by Cross(s). If no N is specified, Cross assumes N = 1 as default.\n\nCross generates a mfe-structure based on specific loop-types of 3-noncrossing RNA structures. For a given structure S, let \u03b1 be an arc contained in S (S-arc) and denote the set of S-arcs that cross \u03b1 by . For two arcs \u03b1 = (i, j) and \u03b1' = (i', j'), we next specify the partial order \"\u227a\" over the set of arcs:\n\nAll notions of minimal or maximal elements are understood to be with respect to \u227a. An arc \u03b1 \u2208  is called a minimal, \u03b2-crossing if there exists no \u03b1' \u2208  such that \u03b1' \u227a \u03b1. Note that \u03b1 \u2208  can be minimal \u03b2-crossing, while \u03b2 is not minimal \u03b1-crossing. 3-noncrossing diagrams exhibit the following four basic loop-types:\n\n(1) A hairpin-loop is a pair\n\nwhere (i, j) is an arc and [i, j] is an interval, i.e. a sequence of consecutive, isolated vertices (i, i + 1, ..., j - 1, j).\n\n(2) An interior-loop, is a sequence\n\nwhere (i2, j2) is nested in (i1, j1). That is we have i1 < i2 < j2 < j1.\n\n(3) A multi-loop, see Figure 11[19], is the closed structure formed by(3)\n\nwhere  denotes the substructure over the interval [\u03c9h, \u03c4h], subject to the condition that if all these substructures are simply stems, then there are at least two of them, see Figure 6.\n\nA pseudoknot, see Figure 12[19], consists of the following data:\n\n(P1) A set of arcs\n\nwhere i1 = min{ih} and jt = max{jh}, such that\n\n(i) the diagram induced by the arc-set P is irreducible, i.e. the dependency-graph of P (i.e. the graph having P as vertex set and in which \u03b1 and \u03b1' are adjacent if and only if they cross) is connected and\n\n(ii) for each (ih, jh) \u2208 P there exists some arc \u03b2 (not necessarily contained in P) such that (ih, jh) is minimal \u03b2-crossing.\n\n(P2) Any i1 <x <jt, not contained in hairpin-, interior- or multi-loops.\n\nHaving discussed the basic loop-types, we are now in position to state\n\nTheorem 1 Any 3-noncrossing RNA pseudoknot structure has a unique loop-decomposition [19].\n\nFigure 13 illustrates the loop decomposition of a 3-noncrossing structure.\n\nIn order to discuss the organization of Cross, we introduce the basic idea behind motifs and skeleta, combinatorial structures used in the folding algorithm.\n\nA motif is a 3-noncrossing structure, having only \u227a-maximal stacks of size exactly \u03c3, i.e. no stacks nested in other stacks, see Figure 14. Despite that motifs can exhibit complicated crossings, they can be inductively generated. A skeleton, S is a k-noncrossing structure such that\n\n\u2022 its core, c(S) has no noncrossing arcs and\n\n\u2022 its L-graph, L(S) is connected.\n\nHere the core of a structure, c(S), is obtained by collapsing its stacks into single arcs (thereby reducing its length) and the graph L(S) is obtained by mapping arcs into vertices and connecting any two if they cross in the diagram representation of S, see Figure 15. A skeleton reflects all cross-serial interactions of a structure.\n\nHaving introduced motifs and skeleta we can proceed by discussing the general idea of Cross. The algorithm generates 3-noncrossing RNA structure \"from top to bottom\" via the following three subroutines:\n\nI (SHADOW): In this routine we generate all maximal stacks of the structure. Note that a stack is maximal with respect to \u227a if it is not nested in some other stack. This is derived by \"shadowing\" the motifs, i.e. their \u03c3-stacks are extended \"from top to bottom\".\n\nII (SKELETONBRANCH): Given a shadow, the second step of Cross consists in generating, the skeleta-tree. The nodes of this tree are particular 3-noncrossing structures, obtained by successive insertions of stacks. Intuitively, a skeleton encapsulates all cross-serial arcs that cannot be recursively computed. Here the tree complexity is controlled via limiting the (total) number of pseudoknots.\n\nIII (SATURATION): In the third subroutine each skeleton is saturated via DP-routines. After the saturation the mfe-3-noncrossing structure is derived.\n\nFigure 16 provides an overview on how the three subroutines are combined.\n\nIn this section we describe Steps 2 and 3 of the pseudocodes presented in Algorithm 7.1. The routine MAKE-START, see line 8, generates a random sequence, start, which is compatible to the target, with uniform probability.\n\nWe then initialize the variable seqmin via the sequence start and set the variable d = + \u221e, where d denotes the structure distance between Cross(seqmin) and T.\n\nGiven the sequence start, we construct a set of potential \"competitors\", C, i.e. a set of structures suited as folding targets for start. In Algorithm 7.2 we show how to adjust the start sequence using the routine ADJUST-SEQ. Lines 3 to 36 of Algorithm 7.2, contain a For-loop, executed at most  times. Here the loop-length  is heuristically determined.\n\nFor all computer experiments setting the Cross-parameter N = 50, the subroutine executed in the loop-body consists of the following three steps.\n\nStep I. Generating C0(\u03bbi) via Cross. Suppose we are in the ith step of the For-loop and are given the sequence \u03bbi-1 where \u03bb0 = start. We consider Cross(\u03bbi-1, N), i.e. the list of suboptimal structures with respect to \u03bbi-1,\n\nIf , then Inv returns \u03bbi-1. Else, in case of , we set\n\nOtherwise we do not update seqmin and go directly to Step II.\n\nStep II. The competitors. We introduce a specific procedure that \"perturbs\" arcs of a given RNA pseudoknot structure, S. Let a be an arc of S and let l(a), r(a) denote the start- and end-point of a. A perturbation of a is a procedure which generates a new arc a', such that\n\nClearly, there are nine perturbations of any given arc a (including a itself), see Figure 17.\n\nWe proceed by keeping a, replacing the arc a by a nontrivial perturbation or remove a, arriving at a set of ten structures \u03bd(S, a).\n\nNow we use this method in order to generate the set C1(\u03bbi-1) by perturbing each arc of each structure . If  has Ah arcs, , then\n\nThis construction may result in duplicate, inconsistent or incompatible structures. Here, a structure is inconsistent if there exists at least one position paired with more than one base, and incompatible if there exists at least one arc not compatible with \u03bbi-1, see Figures 18 and 19. Here compatibility is understood with respect to the Watson-Crick and G-U base pairing rules. Deleting inconsistent and incompatible structures, as well as those identical to the target, we arrive at the set of competitors,\n\nStep III. Mutation. Here we adjust \u03bbi-1 with respect to T as well as the set of competitors, C(\u03bbi-1) derived in the previous step. Suppose . Let p(S, w) be the position paired to the position w in the RNA structure S \u2208 C(\u03bbi-1), or 0 if position w is unpaired. For instance, in Figure 20, we have p(T, 1) = 4, p(T, 2) = 0 and p(T, 4) = 1. For each position w of the target T, if there exists a structure Ch(\u03bbi-1) \u2208 C(\u03bbi-1) such that p(Ch(\u03bbi-1, w) \u2260 p(T, w) (see positions 5, 6, 9, and 11 in Figure 20) we modify \u03bbi-1 as follows:\n\n1. unpaired position: If p(T, w) = 0, we update  randomly into the nucleotide , such that for each Ch(\u03bbi-1) \u2208 C(\u03bbi-1), either p(Ch(\u03bbi-1), w) = 0 or  is not compatible with  where v = p(Ch(\u03bbi-1), w) < 0, See position 6 in Figure 20.\n\n2. start-point: If p(T, w) <w, set v = p(T, w), We randomly choose a compatible base pair () different from (, ) such that for each Ch(\u03bbi-1) \u2208 C(\u03bbi-1), either p(Ch(\u03bbi-1), w) = 0 or  is not compatible with , where u = p(Ch(\u03bbi-1), w) > 0 is the end-point paired with  in Ch(\u03bbi-1) (Figure 20: (5, 9). The pair G-C retains the compatibility to (5, 9), but is incompatible to (5, 10)). By Figure 21 we show feasibility of this step.\n\n3. end-point: If 0 <p(T, w) <w, then by construction the nucleotide has already been considered in the previous step.\n\nTherefore, updating all the nucleotides of \u03bbi-1, we arrive at the new sequence .\n\nNote that the above mutation steps heuristically decrease the structure distance. However, the resulting sequence is not necessarily incompatible to all competitors. For instance, consider a competitor Ch whose arcs are all contained T. Since \u03bbi is compatible with T, \u03bbi is compatible with Ch. Since competitors are obtained from suboptimal folds such a scenario may arise.\n\nIn practice, this situation represents not a problem, since these type of competitors are likely to be ruled out by virtue of the fact that they have a mfe larger than that of the target structure.\n\nAccordingly we have the following situation, competitors are eliminated due to two, equally important criteria: incompatibility as well as minimum free energy considerations.\n\nIf the distance of Cross(\u03bbi) to T is less than or equal to dmin + 5, we return to Step I (with \u03bbi). Otherwise, we repeat Step III (for at most 5 times) thereby generating  and set  where d(Cross(), T) is minimal.\n\nThe procedure ADJUST-SEQ employs the negative paradigm [16] in order to exclude energetically close conformations. It returns the sequence seqmiddle which is tailored to realize the target structure as mfe-fold.\n\nIn this section we introduce two the routines, DECOMPOSE and LOCAL-SEARCH. The routine DECOMPOSE partitions T into linearly ordered energy independent components, see Figure 13 and Section 2.1. LOCAL-SEARCH constructs iteratively an optimal sequence for T via local solutions, that are optimal to certain substructures of T.\n\nDECOMPOSE: Suppose T is decomposed as follows,\n\nwhere the Tw are the loops together with all arcs in the associated stems of the target.\n\nWe define a linear order over B as follows: Tw <Th if either\n\n1. Tw is nested in Th, or\n\n2. the start-point of Tw precedes that of Th.\n\nIn Figure 22 we display the linear order of the loops of the structure shown in Figure 13.\n\nNext we define the interval\n\nprojecting the loop Tw onto the interval [l(Tw), r(Tw)] and bw = [l', r'] \u2283 aw, being the maximal interval consisting of aw and its adjacent unpaired consecutive nucleotides, see Figure 13. Given two consecutive loops Tw <Tw + 1, we have two scenarios:\n\n\u2022 either bw and bw+1 are adjacent, see b5 and b6 in Figure 22,\n\n\u2022 or bw \u2286 bw + 1, see b1 and b2 in Figure 22.\n\nLet , then we have the sequence of intervals a1, b1, c1, ..., am', bm', cm'. If there are no unpaired nucleotides adjacent to aw, then aw = bw and we simply delete all such bw. Thereby we derive the sequence of intervals I1, I2, ..., Im. In Figure 23 we illustrate how to obtain this interval sequence: here the target decomposes into the loops T1, T2 and we have I1 = [3, 5], I2 = [3, 6], I3 = [2, 9], and I4 = [1, 10].\n\nLOCAL-SEARCH: Given the sequence of intervals I1, I2, ...,  Im. We proceed by performing a local stochastic search on the subsequences  (initialized via seq = seqmiddle and where s|[x, y] = sxsx + 1 ... sy). When we perform the local search on , only positions that contribute to the distance to the target, see Figure 10, or positions adjacent to the latter, will be altered. We use the arrays U1, U2 to store the unpaired and paired positions of T. In this process, we allow for mutations that increase the structure distance by five with probability 0.1. The latter parameter is heuristically determined. We iterate this routine until the distance is either zero or some halting criterion is met.\n\nThe main result of this paper is the presentation of the algorithm Inv, freely available at http://www.combinatorics.cn/cbpc/inv.html\n\nIts input is a 3-noncrossing RNA structure T, given in terms of its base pairs (i1, i2) (where i1 <i2). The output of Inv is an RNA sequences s = (s1s2...sn), where sh \u2208 {A, C, G, G} with the property Cross(s) = T, see Figure 24.\n\nThe core of Inv is a stochastic local search routine which is based on the fact that each 3-noncrossing RNA structure has a unique loop-decomposition, see Theorem 1 in Section 2.1. Inv generates \"optimal\" subsequences and eventually arrives at a global solution for T itself. Inv generalizes the existing inverse folding algorithm by considering arbitrary 3-noncrossing canonical pseudoknot structures. Conceptually, Inv differs from INFO-RNA in how the start sequence is being generated and the particulars of the local search itself.\n\nAs discussed in the introduction it has to be given an argument as to why the inverse folding of pseudoknot RNA structures works. While folding maps into RNA secondary structures are well understood, the generalization to 3-noncrossing RNA structures is nontrivial. However the combinatorics of RNA pseudoknot structures [27,28,38] implies the existence of large neutral networks, i.e. networks composed by sequences that all fold into a specific pseudoknot structure. Therefore, the fact that it is indeed possible to generate via Inv sequences contained in the neutral networks of targets against competing pseudoknot configurations, see Figure 24 and Figure 25 confirms the predictions of [31].\n\nAn interesting class are the 3-noncrossing nonplanar pseudoknot structures. A nonplanar pseudoknot structure is a 3-noncrossing structure which is not a bi-secondary structure in the sense of Stadler [30]. That is, it cannot be represented by noncrossing arcs using the upper and lower half planes. Since DP-folding paradigms of pseudoknots folding are based on gap-matrices [15], the minimal class of \"missed\" structures (given the implemented truncations) are exactly these, nonplanar, 3-noncrossing structures. In Figure 26 we showcase a nonplanar RNA pseudoknot structure and 3 sequences of its neutral network, generated by Inv.\n\nAs for the complexity of Inv, the determining factor is the subroutine LOCAL-SEARCH. Suppose that the target is decomposed into m intervals with the length \u21131, ...., \u2113m. For each interval, we may assume that line 2 of LOCAL-SEARCH runs for fh times, and that line 14 is executed for gh times. Since LOCAL-SEARCH will stop (line 4) if Tstart = T (line 3), the remainder of LOCAL-SEARCH, i.e. lines 7 to 41 run for (fh - 1) times, each such execution having complexity O(\u2113h). Therefore we arrive at the complexity\n\nwhere c(\u2113) denotes the complexity of the Cross. The multiplicities fh and gh depend on various factors, such as start, the random order of the elements of U1, U2 (see Algorithm 7.3) and the probability p. According to [32] the complexity of c(\u2113h) is  and accordingly the complexity of Inv is given by\n\nIn Figure 27 we present the average inverse folding time of several natural RNA structures taken from the PKdatabase [39]. These averages are computed via generating 200 sequences of the target's neutral networks. In addition we present in Table 1 the total time for 100 executions of Inv for an additional set of RNA pseudoknot structures.\n\nThe authors declare that they have no competing interests.\n\nAll authors contributed equally to this paper. All authors read and approved the final manuscript.\n\n7.1 Algorithm 7.1 - INVERSE-FOLD\n\nInput: k-noncrossing target structure T\n\nOutput: an RNA sequence seq\n\nRequire: k \u2264 3 and T is composed of \":( ) [ ] { }\"\n\nEnsure: Cross(seq) = T\n\n1. \u25bb Step 1: Validate structure\n\n2. if false = CHECK-STRU(T) then\n\n3.    print incorrect structure\n\n4.    return NIL\n\n5. end if\n\n6.\n\n7. \u25bb Step 2: Generate the start sequence\n\n8. start \u2190 MAKE-START(T)\n\n9.\n\n10. \u25bb Step 3: Adjust the start sequence\n\n11. seqmiddle \u2190 ADJUST-SEQ(start, T)\n\n12.\n\n13. \u25bb Step 4: Decompose T and derive the ordered intervals.\n\n14. Interval array I\n\n15. m \u2190 |I| \u25bb I satisfies Im = T\n\n16.\n\n17. \u25bb Step 5: Stochastic Local Search\n\n18. seq \u2190 seqmiddle\n\n19. for all intervals in the array Iw do\n\n20.    l \u2190 start-point(Iw)\n\n21.    r \u2190 end-point(Iw)\n\n22.    s' \u2190 seq|[l, r] \u25bb get sub-sequence\n\n23.    seq|[l, r] LOCAL-SEARCH(s', Iw)\n\n24. end for\n\n25.\n\n26. \u25bb Step 6: output\n\n27. if seqmin = Cross(seq) then\n\n28.    return seq\n\n29. else\n\n30.    print Failed!\n\n31.    return NIL\n\n32. end if\n\n7.2 Algorithm 7.2 - ADJUST-SEQ\n\nInput: the original start sequence start\n\nInput: the target structure T\n\nOutput: an initialized sequence seqmiddle\n\n1. n \u2190 length of T\n\n2. dmin \u2190 + \u221e, seqmin \u2190 start\n\n3. for i = 1 to  do\n\n4.    \u25bb Step I: generate the set C0(\u03bbi - 1) via Cross\n\n5.    C0(\u03bbi - 1) \u2190 Cross(\u03bbi - 1, N)\n\n6.    \n\n7. if d = 0 then\n\n8.       return \u03bbi - 1\n\n9.    else if d <dmin then\n\n10.       dmin \u2190 d, seqmin \u2190 \u03bbi - 1\n\n11.    end if\n\n12.\n\n13.    \u25bb Step II: generate the competitor set C(\u03bbi - 1)\n\n14.    C1(\u03bbi-1) \u2190 \u03d5\n\n15.    for all  \u2208 C1(\u03bbi-1) do\n\n16.       for all arc  of do\n\n17.          \n\n18.       end for\n\n19.    end for\n\n20.    C(\u03bbi - 1) =\n\n21.    { is valid}\n\n22.\n\n23.    \u25bb Step III: mutation\n\n24.    seq \u2190 \u03bbi - 1\n\n25.    for w = 1 to n do\n\n26.       if \u2203 Ch(\u03bbi-1) \u2208 C(\u03bbi-1) s.t. p(Ch, w) \u2260 p(T, w) then\n\n27.          seq[w] \u2190 random nucleotide or pair, s.t. seq \u2208 C[T] and seq \u2209 C[Ch(\u03bbi-1)]\n\n28.       end if\n\n29.    end for\n\n30.    Tseq \u2190 Cross(seq)\n\n31.    if d(Tseq, T) <dmin + 5 then\n\n32.       seqmiddle \u2190 seq\n\n33.    else if Step III run less than 5 times then\n\n34.       goto Step III\n\n35.    end if\n\n36. end for \u25bb loop to line 3\n\n37.\n\n38. return seqmiddle\n\n7.3 Algorithm 7.3 - LOCAL-SEARCH\n\nInput:seqmiddle\n\nInput: the target T\n\nOutput: seq\n\nEnsure: Cross(seq) = T\n\n1. seq \u2190 seqmiddle\n\n2. if Cross(seq) = T then\n\n3.    return seq\n\n4. end if\n\n5. decompose T and derive the ordered intervals\n\n6. I \u2190 [I1, I2, ..., Im]\n\n7. for all Iw in I do\n\n8.    \u25bb Phase I: Identify positions\n\n9.     \u25bb initialize dmin\n\n10.\n\n11.    derive U1 via \n\n12.    derive U2 via \n\n13.\n\n14.    \u25bb Phase II: Test and Update\n\n15.    for all p in U1 do\n\n16.       random T compatible mutate seqp\n\n17.    end for\n\n18.    for all [p, q] in U2 do\n\n19.       random T compatible mutate seqp\n\n20.    end for\n\n21.\n\n22.    E \u2190 \u03d5\n\n23.    for all p \u2208 U1, U2 do\n\n24.       d \u2190 d(T, Cross(seqp))\n\n25.       if d <dmin then\n\n26.          dmin \u2190 d, seq \u2190 seqp\n\n27.          goto Phase I\n\n28.       else if dmin <d <dmin + 5 then\n\n29.          goto Phase I with the probability 0.1\n\n30.       end if\n\n31.       if d = dmin then\n\n32.          E \u2190 E \u222a {seq}\n\n33.       end if\n\n34.    end for\n\n35.    seq \u2190 e0 \u2208 E, where e0 has the lowest mfe in E\n\n36.    if Phase I run less than 10 n times then\n\n37.       goto Phase I\n\n38.    end if\n\n39. end for\n\n40. return seq\n\nWe are grateful to Fenix W.D. Huang for discussions. Special thanks belongs to the two anonymous referee's whose thoughtful comments have greatly helped in deriving an improved version of the paper. This work was supported by the 973 Project, the PCSIRT of the Ministry of Education, the Ministry of Science and Technology, and the National Science Foundation of China."}
{"title": "Epidemic curves made easy using the R package\nincidence\n", "body": "Responses to infectious disease epidemics use a growing body of data sources to inform decision making (\nCori\net al., 2017;\nFraser\net al., 2009;\nWHO Ebola Response Team\net al., 2014;\nWHO Ebola Response Team\net al., 2015). While new data\u2014such as whole genome pathogen sequences\u2014are increasingly useful complements to epidemiological data (\nGire\net al., 2014), epidemic curves\u2014which describe the number of new cases through time (incidence)\u2014remain the most important source of information, particularly early in an outbreak. Specifically epidemic curves(often referred to as \u2018epicurves\u2019) represent the number of new cases per time unit based on the date or time of symptom onset.\n\nWhile conceptually simple, epicurves are useful in many respects. They provide a simple, visual outline of epidemic dynamics, which can be used for assessing the growth or decline of an outbreak (\nBarrett\net al., 2016;\nFitzgerald\net al., 2014;\nJernberg\net al., 2015;\nLanini\net al., 2014;\nNhan\net al., 2018) and therefore informing intervention measures (\nMeltzer\net al., 2014;\nWHO Ebola Response Team\net al., 2014;\nWHO Ebola Response Team\net al., 2015). In addition, epicurves also form the raw material used by a range of modelling techniques for short-term forecasting (\nCori\net al., 2013;\nFunk\net al., 2018;\nNouvellet\net al., 2018;\nViboud\net al., 2018) as well as in outbreak detection algorithms from syndromic surveillance data (\nFarrington & Andrews, 2003;\nUnkel\net al., 2012).\n\nBecause of the increasing need to analyse various types of epidemiological data in a single environment using free, transparent and reproducible procedures, the R software (\nR Core Team, 2017) has been proposed as a platform of choice for epidemic analysis (\nJombart\net al., 2014). But despite the existence of packages dedicated to time series analysis (\nShumway & Stoffer, 2010) as well as surveillance data (\nH\u00f6hle, 2007), a lightweight and\nwell-tested package solely dedicated to building, handling and plotting epidemic curves directly from linelist data (e.g. a spreadsheet where each row represents an individual case) is still lacking.\n\nHere, we introduce\nincidence, an R package developed as part of the toolbox for epidemics analysis of the R Epidemics Consortium (\nRECON) which aims to fill this gap. In this paper, we outline the package\u2019s design and illustrate its functionalities using a reproducible worked example.\n\nThe philosophy underpinning the development of\nincidence is to \u2018do the basics well\u2019. The objective of this package is to provide simple, user-friendly and robust tools for computing, manipulating, and plotting epidemic curves, with some additional facilities for basic models of incidence over time.\n\nThe general workflow (\nFigure 1) revolves around a single type of object, formalised as the S3 class\nincidence.\nincidence objects are lists storing separately a matrix of case counts (with dates in rows and groups in columns), dates used as breaks, the time interval used, and an indication of whether incidence is cumulative or not (\nFigure 1). The\nincidence object is obtained by running the function\nincidence() specifying two inputs: a vector of dates (representing onset of individual cases) and an interval specification. The dates can be any type of input representing dates including\nDate and\nPOSIXct objects, as well as numeric and integer values. The dates are aggregated into counts based on the user-defined interval representing the number of days for each bin. The interval can also be defined as a text string of either \"week\", \"month\", \"quarter\", or \"year\" to represent intervals that can not be defined by a fixed number of days. For these higher-level intervals, an extra parameter\u2014\nstandard\u2014is available to specify if the interval should start at the standard beginning of the interval (e.g. weeks start on Monday and months start at the first of the month).\nincidence() also accepts a\ngroups argument which can be used to obtain stratified incidence. The basic elements of the\nincidence object can be obtained by the accessors\nget_counts(),\nget_dates(), and\nget_interval().\n\nThis package facilitates the manipulation of\nincidence objects by providing a set of handler functions for the most common tasks. The function\nsubset() can be used for isolating case data from a specific time window and/or groups, while the [ operator can be used for a finer control to subset dates and groups using integer, logical or character vectors. This is accomplished by using the same syntax as for matrix and data.frame objects, i.e.\nx[i, j] where\nx is the\nincidence object, and\ni and\nj are subsets of dates and groups, respectively.\n\nThe function\npool() can be used to merge several groups into one, and the function\ncumulate() will turn incidence data into cumulative incidence. To maximize interoperability,\nincidence objects can also be exported to either a matrix using\nget_counts() or a data.frame using\nas.data.frame(), including an option for a \u2018long\u2019 format which is readily compatible with\nggplot2 (\nWickham, 2016) for further customization of graphics.\n\nIn line with RECON\u2019s development guidelines, the\nincidence package is thoroughly tested via automatic tests implemented using\ntestthat (\nWickham, 2011), with an overall coverage nearing 100% at all times. We use the continuous integration services\ntravis.ci and\nappveyor to ensure that new versions of the code maintain all existing functionalities and give expected results on known datasets, including matching reference graphics tested using the visual regression testing implemented in\nvdiffr (\nHenry\net al., 2018). Overall, these practices aim to maximise the reliability of the package, and its sustainable development and maintenance over time.\n\nMany different approaches can be used to model, and possibly derive predictions from incidence data (e.g.\nCori\net al., 2013;\nNouvellet\net al., 2018;\nWallinga & Teunis, 2004), and are best implemented in separate packages (e.g.\nCori\net al., 2013). Here, we highlight three simple functionalities in\nincidence for estimating parameters via modeling or bootstrap and the two specialized data classes that are used to store the models and parameter estimates.\n\nAs a basic model, we implement the simple log-linear regression approach in the function\nfit(), which can be used to fit exponential increase or decrease of incidence over time by log-transforming case counts and applying a linear regression on these transformed data. The log-linear regression model is of the form\nlog(\ny) =\nr \u00d7 t +\nb where\ny is the incidence,\nr is the growth rate,\nt is the number of days since the start of the outbreak, and\nb is the intercept. This approach estimates a growth rate\nr (the slope of the regression), which can in turn be used for estimating the doubling or halving time of the epidemic, and with some knowledge of the serial interval, for approximating the reproduction number,\nR\n0 (\nWallinga & Lipsitch, 2007).\n\nIn the presence of both growing and decreasing phases of an epidemic, the date representing the peak of the epidemic can be estimated. In\nincidence, this can be done in two ways. The function\nestimate_peak() uses multinomial bootstrapping to estimate the peak, assuming that a) reporting is constant over time, b) the total number of cases is known, and c) the bootstrap never samples zero-incidence days. This function returns the estimated peak with a confidence interval along with the boostrap estimates. Alternatively, the function\nfit_optim_split() can be used to detect the optimal turning point of the epidemic and fit two separate models on either side of the peak. This is done by maximizing the combined mean adjusted\nR\n2 value from the two models (\nFigure 1,\nFigure 5).\n\nThe\nfit() function returns an\nincidence_fit object and the\nfit_optim_split() function returns an\nincidence_fit_list object, which is a specialized object designed to contain an unlimited number of (potentially nested)\nincidence_fit objects. While the\nincidence package returns\nincidence_fit objects containing log-linear models by default, they can be constructed from any model from which it\u2019s possible to extract the growth rate (\nr) and predict incidence along the model. Both object classes can be plotted separately or added to an existing epicurve using the function\nadd_incidence_fit() (\nFigure 5).\n\nThe minimal system requirements for successful operation of this package is R version 3.1.\n\nIn this first example, we use the dataset\nebola_sim_clean in the\noutbreaks package, which provides a linelist for a fictitious outbreak of Ebola Virus Disease (EVD) that matches some key epidemiological properties (e.g. serial intervals, reproduction numbers) of the West African Ebola outbreak of 2014\u20132015 (\nWHO Ebola Response Team\net al., 2014).\n\n\n1) Importing data\n\n\nFirst, we load the dataset\nebola_sim_clean from the\noutbreaks package. The dataset contains 5,829 cases of 9 variables, among which the date of symptom onset (\n$date_of_onset) and the name of the hospital (\n$hospital) are used for computing the weekly epicurves stratified by hospitals.\n\nlibrary('outbreaks')\ndat1 <- ebola_sim_clean$linelist\nstr(dat1, strict.width = \"cut\", width = 76)\n## 'data.frame':      5829 obs.  of  9 variables:\n##  $ case_id                   : chr  \"d1fafd\" \"53371b\" \"f5c3d8\" \"6c286a\" ...\n##  $ generation                : int  0 1 1 2 2 0 3 3 2 3 ...\n##  $ date_of_infection         : Date, format: NA \"2014-04-09\" ...\n##  $ date_of_onset             : Date, format: \"2014-04-07\" \"2014-04-15\" ...\n##  $ date_of_hospitalisation   : Date, format: \"2014-04-17\" \"2014-04-20\" ...\n##  $ date_of_outcome           : Date, format: \"2014-04-19\" NA ...\n##  $ outcome                   : Factor w/ 2 levels \"Death\",\"Recover\": NA NA 2 ..\n##  $ gender                    : Factor w/ 2 levels \"f\",\"m\": 1 2 1 1 1 1 1 1 2 ..\n##  $ hospital                  : Factor w/ 5 levels \"Connaught Hospital\",..: 2 ..\n\n\n2) Building the incidence object\n\n\nThe weekly incidence stratified by hospitals is computed by running the function\nincidence() on the Date variable\ndat1$date_of_onset with the arguments\ninterval = 7 and\ngroups = dat1$hospital. The\nincidence object\ni.7.group is a list with class of\nincidence for which several generic methods are implemented, including\nprint.incidence() and\nplot.incidence(). Typing\nincidence object\ni.7.group implicitly calls the specific function\nprint.incidence() and prints out the summary of the data and its list components. The 5,829 cases (the total number of cases stored in the\n$n component) with dates of symptom onset ranging from 2014-04-07 to 2015-04-27 (spanning from 2014-W15 to 2015-W18 in terms of the ISO 8601 standard for representing weeks) are used for building the\nincidence object\ni.7.group. The\n$counts component contains the actual incidence for defined bins, which is a matrix with one column per group. Here\n$count is a matrix with 56 rows and 6 columns as groups by hospital with 6 factor levels are specified. The bin size in number of days is stored in the\n$interval component. In this example, 7 days suggests that weekly incidence is computed, while by default, daily incidence is computed with the argument\ninterval = 1. The\n$dates component contains all the dates marking the left side of the bins, in the format of the input data (e.g. Date, integer, etc.). The\n$timespan component stores the length of time (in days) for which incidence is computed. The\n$cumulative component is a logical indication whether incidence is cumulative or not.\n\nThe generic\nplot() method for\nincidence objects calls the specific function\nplot.incidence(), which makes an incidence barplot using the\nggplot2 package. Hence, customization of\nincidence plot can benefit from the powerful graphical language from\nggplot2.\n\n\nlibrary('incidence')\nlibrary('ggplot2')\n# compute weekly stratified incidence\ni.7.group <- incidence(dat1$date_of_onset, interval = 7, groups = dat1$hospital)\n# print incidence object\ni.7.group\n## <incidence object>\n## [5829 cases from days 2014-04-07 to 2015-04-27]\n## [5829 cases from ISO weeks 2014-W15 to 2015-W18]\n## [6 groups: Connaught Hospital, Military Hospital, other,\n##  Princess Christian Maternity Hospital (PCMH), Rokupa Hospital, NA]\n##\n## $counts: matrix with 56 rows and 6 columns\n## $n: 5829 cases in total\n## $dates: 56 dates marking the left-side of bins\n## $interval: 7 days\n## $timespan: 386 days\n## $cumulative: FALSE\n# plot incidence object\nmy_theme <- theme_bw(base_size = 12) +\ntheme(panel.grid.minor = element_blank()) +\ntheme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5, color = \"black\"))\nplot(i.7.group, border = \"white\") +\nmy_theme +\ntheme(legend.position = c(0.8, 0.75))\n\nNote that when weekly incidence is computed from dates, like in this example, the ISO 8601 standard weeks are used by default with the argument\nstandard = TRUE in the\nincidence() function. Under this situation, an extra component of\n$isoweek is added to the\nincidence object\ni.7.group to store those weeks in the ISO 8601 standard week format \u201cyyyy-Www\u201d, and the\n$dates component stores the corresponding first days of those ISO weeks. Meanwhile the x-axis tick labels of the weekly\nincidence plot are in the ISO week format \u201cyyyy-Www\u201d (see\nFigure 2) rather than in the date format \u201cyyyy-mm-dd\u201d as the argument\nlabels_iso_week in the\nplot() function is by default\nTRUE when plotting the ISO week-based\nincidence objects.\n\n\n3) Manipulate the incidence object\n\n\nIn the above visualisation, it can be difficult to see what the dynamics were in the early stages of the epidemic. If we want to see the first 18 weeks of the outbreak in the four major hospitals, we can use the [ operator to subset the rows and columns, which represent weeks and hospitals, respectively, in this particular\nincidence object.\n\n# plot the first 18 weeks, defined hospitals, and use different colors\ni.7.sub <- i.7.group[1:18, grep(\"Hospital\", group_names(1.7.group))]\nhosp_colors <- c(\"#899DA4\", \"#C93312\", \"#FAEFD1\", \"#DC863B\")\nplot(i.7.sub, show_cases = TRUE, border = \"black\", color = hosp_colors) +\nmy_theme +\ntheme(legend.position = c(0.35, 0.8))\n\nHere, because of the few numbers of cases in the first few weeks, we have also highlighted each case using\nshow_cases = TRUE (\nFigure 3). We\u2019ve also used a different color palette to differentiate between the subsetted data and the full data set.\n\nAs shown in\nFigure 2, the missing hospital name (NA) is treated as a separate group, resulting from the default of the argument\nna_as_group = TRUE in the\nincidence() function. This argument can be set to\nFALSE to not include data with missing groups in the object.\n\nThe datasets\nzika_girardot_2015 and\nzika_sanandres_2015 used in the second example are also from the\noutbreaks package. These datasets describe the daily incidence of Zika virus disease (ZVD) in, respectively, Girardot and San Andres Island, Colombia from September 2015 to January 2016. For details on these datasets, please refer to\nRojas\net al. (2016).\n\n\n1) Import pre-computed daily incidence\n\n\n\nzika_girardot_2015 and\nzika_sanandres_2015 are data frames with the same variables\ndate and\ncases. In order to obtain a more complete picture of the epidemic dynamics of ZVD in Colombia, we merge these two data.frames into a single one,\ndat2, by variable\ndate.\nAs dat2 is already pre-computed daily incidence rather than a vector of dates such as those in example 1, we can directly convert it into an\nincidence object grouped by geographical locations,\ni.group, by using the\nas.incidence() function. This shows the flexibility of the\nincidence package in making\nincidence objects. Using the\npool() function, the daily incidence stratified by locations,\ni.group, can be collapsed into an incidence object without groups,\ni.pooled. The stratified and pooled daily incidence plots of ZVD in Colombia are shown in\nFigure 4, from which we can see that the epidemic of ZVD occurred earlier in San Andres Island than in Girardot.\n\n# preview datasets\nhead(zika_girardot_2015, 3)\n##         date cases\n## 1 2015-10-19     1\n## 2 2015-10-22     2\n## 3 2015-10-23     1\nhead(zika_sanandres_2015, 3)\n##         date cases\n## 1 2015-09-06     1\n## 2 2015-09-07     1\n## 3 2015-09-08     1\n# combine two datasets into one\ndat2 <- merge(zika_girardot_2015, zika_sanandres_2015, by = \"date\", all = TRUE)\n# rename variables\nnames(dat2)[2:3] <- c(\"Girardot\", \"San Andres\")\n# replace NA with 0\ndat2[is.na(dat2)] <- 0\n# convert pre-computed incidence in data.frame into incidence object\n# grouped by locations\ni.group <- as.incidence(x = dat2[, 2:3], dates = dat2$date)\n# pool incidence across two locations\ni.pooled <- pool(i.group)\nplot(i.group, border = \"white\") + my_theme + theme(legend.position = c(0.9, 0.7))\nplot(i.pooled, border = \"white\") + my_theme\n\nAs shown in\nFigure 4B, the pooled daily incidence in Colombia shows approximately exponential phases before and after the epidemic peak. Therefore, we fit two log-linear regression models around the peak to characterize the epidemic dynamics of ZVD in Colombia. Such models can be separately fitted to the two phases of the epicurve of\ni.pooled using the\nfit() function, which, however, requires us to know what date should be used to split the epicurve in two phases (see the argument\nsplit in the\nfit() function). Without any knowledge on the splitting date, we can turn to the\nfit_optim_split() function to look for the optimal splitting date (i.e. the one maximizing the average fit of both models) and then fit two log-linear regression models before and after the optimal splitting date.\n\nlibrary('magrittr')\nfos <- fit_optim_split(i.pooled)\nfos$split\n## [1] \"2015-11-15\"\nfos$fit\n## <list of incidence_fit objects>\n##\n## attr(x, 'locations'): list of vectors with the locations of each incidence_fit object\n##\n## 'before'\n## 'after'\n##\n## $model: regression of log-incidence over time\n##\n## $info: list containing the following items:\n##   $r (daily growth rate):\n##      before       after\n##  0.06659200 -0.04813045\n##\n##   $r.conf (confidence interval):\n##              2.5 %      97.5 %\n## before  0.05869968  0.07448432\n## after  -0.05440018 -0.04186071\n##\n##   $doubling (doubling time in days):\n##   before\n## 10.40887\n##\n##   $doubling.conf (confidence interval):\n##           2.5 %   97.5 %\n## before 9.305948 11.80836\n##\n##   $halving (halving time in days):\n##    after\n## 14.40143\n##\n##   $halving.conf (confidence interval):\n##          2.5 %   97.5 %\n## after 12.74163 16.55842\n##\n##   $pred: data.frame of incidence predictions (129 rows, 6 columns)\nplot(i.pooled, border = \"white\") %>%\nadd_incidence_fit(fos$fit) +\nmy_theme\n\nThe returned object\nfos is a list with 4 components. The\n$split component suggests that the optimal splitting date is 2015-11-15. The\n$fit component is an\nincidence_fit_list containing two\nincidence_fit objects named \u2018before\u2019 and \u2018after\u2019. These each contain the information extracted from the fitted log-linear regression models. Printing the\n$fit component shows a daily growth rate\nr of 0.067 and its 95% confidence interval (CI) ([0.059, 0.074]), and a doubling time of 10.4 days (95% CI, [9.31, 11.8]) during the first phase, and a daily decreasing rate\nr of -0.048 (95% CI, [-0.054, -0.042]), and a halving time of 14.4 days (95% CI, [12.7, 16.6]) during the second.\n\nThe predictions and their 95% CIs from the two\nincidence_fit objects, \u2018before\u2019 and \u2018after\u2019, can be added to the existing incidence plot of\ni.pooled using the piping-friendly function\nadd_incidence_fit(). As shown in\nFigure 5, based on visual comparison of models and data, these two log-linear regression models provide a decent approximation for the actual dynamics of the epidemic (adjusted\nR\n2 = 0.83 and 0.77 for the increasing and decreasing phases, respectively).\n\nThis article has described the package\nincidence and its features\u2014which include three lightweight data classes and utilities for data manipulation, plotting, and modeling. We have shown that an\nincidence object can flexibly be defined at different datetime intervals with any number of stratifications and be subset by groups or dates. The most important aspects of this package are use-ability and interoperability. For both field epidemiologists and academic modellers, the data received are often in the form of line-lists where each row represents a single case. We have shown that these data can easily be converted to an\nincidence object and then plotted with sensible defaults in two lines of code.\n\nWe have additionally shown that because the data are aggregated into a matrix of counts, it becomes simple to perform operations related to peak-finding, model-fitting, and exportation (e.g. using\nas.data.frame()) into different formats. Thus, because it has built-in tools for aggregation, visualisation, and model fitting, the\nincidence package is ideal for rapid generation of reports and estimates in outbreak response situations where time is a critical factor.\n\n\nincidence available from:\nhttps://www.repidemicsconsortium.org/incidence Code to reproduce all figures can be found by running\ndemo (\"incidence-demo\", package = \"incidence\") from the R console with the incidence package installed.\n\nSource code available from:\nhttps://github.com/reconhub/incidence\n\n\nArchived source code as at time of publication:\nhttps://doi.org/10.5281/zenodo.2540217 (\nJombart\net al., 2019)\n\nSoftware license: MIT\n\nDatasets used in the worked examples are from the\noutbreaks package:\n\nebola_sim_clean:\nhttps://github.com/reconhub/outbreaks/blob/master/data/ebola_ sim_clean.RData\n\n\nzika_girardot_2015:\nhttps://github.com/reconhub/outbreaks/blob/master/data/zika_ girardot_2015.RData\n\n\nzika_sanandres_2015:\nhttps://github.com/reconhub/outbreaks/blob/master/data/zika_sanandres_2015.RData\n"}
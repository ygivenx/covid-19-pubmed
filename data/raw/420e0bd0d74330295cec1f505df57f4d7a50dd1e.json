{"title": "To appear in: Knowledge-Based Systems", "body": "Sequential pattern mining (SPM) refers to discover the subsequences (also known as patterns) that satisfy the threshold from given sequences [1, 2, 3] .\n\nIt has been widely applied in various fields, such as big data mining [4, 5] , big data intelligence [6] , e-commerce shopping analysis [7] , biological sequence anal-5 ysis [8] , and event analysis [9] . To handle some specific issues, many methods have been proposed, such as negative SPM [10, 11] , maximal frequent pattern mining [12, 13] , three-way pattern mining [14, 15] , closed SPM [16, 17] , gap constraint SPM [18, 19] .\n\nGap constraint SPM is an important branch of traditional SPM. In tradi- 10 tional SPM, a sequence database is a set of sequences, each sequence is a list of elements, and each element is a set of items. For example, <a(abc)(ac)c(cd)> is a sequence in traditional SPM, since (abc) is an element in the sequence. In gap constraint SPM, a sequence database can be a sequence, and each sequence is a list of items. For example, <aabcacccd> is a sequence in gap constraint SPM. 15 information. For example, in long-length sequences such as DNA, virus, and 20 consumption records, the repetitive occurrences indicate the frequency of patterns, which reflect information discrimination between patterns, and are of high research value.\n\nGap constraint SPM (or gap constraint sequence pattern mining) can avoid finding many useless patterns by setting gap constraints, while repetitive SPM 25 cannot [20, 21] since it does not set gap constraint. Gap constraint SPM is also different from frequent substring mining [22] and n-gram text mining [23] , since the latters mine the pattern without gaps. One key issue of gap constraint SPM is to calculate the support (the number of occurrences) of a pattern in a sequence, which is pattern matching problem [24, 25, 26] . Thus, gap constraint 30 is also called a wildcard gap or flexible wildcards [27, 28] in pattern matching fields. If a pattern has many gaps that are the same, the pattern is called a pattern with periodic gaps [29] , described as P =p 1 [a, b]p 2 \u00b7 \u00b7 \u00b7 p m\u22121 [a, b]p m , where a and b (0\u2264a\u2264b) are the minimum and maximum gap constraints, respectively, and m indicates the pattern length [30] . The size of gap constraints can be flexi- 35 bly set by users, which leads to various applications, such as correlation analysis between DNA and diseases based on gap constraints [29] . Li et al. [31] proposed an effective method to mine the patterns with gap constraints that can be used for feature extraction for sequence classifications [32] . However, introducing gap constraints not only makes the mining method more flexible but also makes the 40 results more complex because the number of patterns increases exponentially as the pattern length increases. To solve this problem, the nonoverlapping condition [33] was proposed, which allows the same sequence letter to match and rematch pattern letters at different positions. Introducing the nonoverlapping condition not only reduces the number of occurrences but also makes the unique Example 1. Given a sequence database SDB ={S 1 =AATCATCA, S 2 =AATGACTACTCAA, 50 S 3 =ATCAGATCAG}. Pattern P =A[0,2]T[0,2]C[0,2]A is a periodic gapped pattern. To make it easier to describe, an occurrence will be described in the form of a sequence landmark. For example, the first occurrence of P in S 1 is s 1 s 3 s 4 s 5 , which can be written as <1,3,4,5>. In this way, the other 2 occurrences of P in Similarly, there are four occurrences of P in both S 2 and S 3 . If we ignore the repetition, the support of P 1 in SDB is 3. If we take the repetition into consideration, the support is 3+4+4=11. The latter method considers occurrences in detail. However, this method also encounters some problems. For example, there are three occurrences for pattern Q= A[0, 2]T in sequence S 4 = 60 AAATCCC, but there are nine occurrences for its super-pattern Q = A[0, 2]T[0, 2]C. This example shows that the number of patterns increases exponentially with increasing pattern length, which does not satisfy the Apriori property [19] .\n\nTo solve the above problem, the nonoverlapping condition was proposed [33] .\n\nWith the nonoverlapping condition, any two occurrences cannot use the same art gap constraint SPM methods in finding useful patterns in biology sequences and avoiding under-expression and over-expression in time series [34] . However, all frequent patterns discovered by NOSEP can be furtherly compressed. An 75 illustrative example is shown as follows.\n\nExample 2. When minsup=2, gap=[0,2], with the nonoverlapping condition, there are 16 frequent patterns in the sequence S 1 = AATCATCA, which are {\"A\", \"AA\", \"AT\", \"AC\", \"TC\", \"CA\", \"AAA\", \"AAC\", \"AAT\", \"ATA\", \"ATC\", \"ACA\",\"AA\", \"TC\", \"AATA\", \"AACA\", \"ATCA\"}. The supports 80 of these patterns are sup(\"A\") =4, sup(\"AA\")=3, and 2 for the remaining patterns. Patterns \"AT\", \"TC\", \"AAT\", and \"ATC\" are unclosed patterns, since these patterns are sub-patterns of pattern \"AATC\" and their supports are all 2. In this way, 16 frequent patterns can be compressed into 6 closed patterns, \"A\", \"AA\", \"AATC\", \"AATA\", \"AACA\", and \"ATCA\". This example shows 85 that closed patterns can effectively compress frequent patterns without losing support information.\n\nTo reduce redundant patterns and improve the mining speed, this paper adopts the closed pattern mining strategy to obtain lossless compression of frequent patterns. The contributions of this paper are as follows: 90 1. The problem of nonoverlapping periodic gapped closed SPM is addressed, and a complete algorithm NetNCSP (Nettree for Nonoverlapping Closed Sequential Pattern) is proposed.\n\n2. To calculate the support, NetNCSP employs the backtracking strategy to match the pattern in the Nettree structure, which reduces the time com-95 plexity. More importantly, NetNCSP adopts three pruning strategies to find closed patterns. We show that NetNCSP is a complete algorithm that satisfies the Apriori property.\n\nNetNCSP is not only more efficient, but also possesses remarkable pattern compressibility.\n\nThe rest of this paper is organized as follows. Section 2 introduces the related work. Section 3 defines the problem. Section 4 proposes the NetNCSP 5 J o u r n a l P r e -p r o o f Journal Pre-proof algorithm, and demonstrates the completeness, complexities, and Apriori property. Section 5 makes a comparative experimental analysis. Section 6 draws the conclusion of this paper.\n\nAgrawal et al. [36] proposed SPM. Based on this research, many achievements have been made, such as high utility mining [37] , contrast SPM [38, 39] , and closed SPM [40, 41] . Closed SPM can effectively compress the frequent patterns [42, 43] . For example, assuming that the supports of patterns \"A\", 110 \"AT\", and \"ATC\" are equal, then patterns \"A\" and \"AT\" are called redundant patterns. Hence, patterns \"A\", \"AT\", \"ATC\" can be compressed into \"ATC\" without losing support information. Besides closed pattern mining, there are other methods to achieve pattern compression, such as generator mining [44] and maximal pattern mining [45] . Generator mining aims to find the set of 115 patterns with minimal length, while closed pattern mining focuses on finding the set of patterns with maximal length. Maximal pattern mining finds the set of patterns whose super-patterns are infrequent. Closed SPM has become a research hotspot because of its impressive compression performance [46, 47] and has been widely used in many essential fields, such as recommendation systems 120 [48], clustering analysis [49, 50, 51] , genetic engineering [52] , disease diagnosis [53] , and software engineering [54, 55] . However, these studies ignored the repetitions that may contain more relevant information in long sequences. Noticing this disadvantage, Ding et al. [33] proposed the CloGSgrow algorithm, which studied the repetitive occurrences of patterns. CloGSgrow calculates the occur- Another important branch of SPM is gap constraint SPM. This method aims to discover subsequences from sequences that satisfy the gap constraints and support threshold. Existing studies are based on three types of conditions, no-condition [29, 56] , one-off condition [8, 57] , and nonoverlapping condition [33, 34, 58] . The no-condition allows sequence letters to be reused by patterns 135 for an unlimited time. Zhang et al. [29] first proposed SPM under no-condition in DNA sequences. However, pattern mining under no-condition does not satisfy the Apriori property, which means it is necessary to expand the search space to mine all frequent patterns [19] . The one-off condition allows the sequence letters to be matched no more than once [59] . In Example 1, there is only one 140 occurrence <1,3,4,5> with the one-off condition. Pattern mining under the oneoff condition was applied to biological sequence mining [8] , which is an NP-Hard problem, since its computational complexity is the same as that of an iterative shuffle problem [60] . Therefore, heuristic strategies are applied to calculate the pattern support. Hence, pattern mining under the one-off condition belongs to 145 approximate mining. The nonoverlapping condition allows the sequence letters to be rematched by the different pattern letters and to be matched no more than once by the same pattern letter. Although the nonoverlapping condition is more complex than the other two, our previous studies have demonstrated that the pattern mining under thee nonoverlapping condition is not only a complete 150 mining method with the Apriori property but can also discover more valuable patterns than the other two conditions [34, 35] . Consequently, pattern mining under the nonoverlapping condition outperforms those of the no-condition and one-off condition. A comparison of the related research work is shown in Table   1 . As can be seen from Table 1 , Reference [34] is the closest to this paper. The differences between Reference [34] and this paper are as follows. To obtain the maximum pattern support, NETGAP prunes the invalid nodes after obtaining a nonoverlapping occurrence [34] . Hence, the time complexity of NETGAP is\n\nwhere m, n, and W are the length of pattern and sequence, 160 and the maximum gap, respectively. However, in this paper, we propose the BackTr algorithm which employs a backtracking strategy to calculate the pattern support without pruning the invalid nodes, which will reduce the time complexity to O(m\u00d7n\u00d7W ). In addition, Reference [34] focused on mining the frequent patterns, while this paper mines the closed patterns and adopts three 165 pruning strategies, inheriting, predicting, and determining to predict the frequency and closeness of the patterns.\n\nDefinition 1. A sequence with length n can be described as S =s 1 \u00b7 \u00b7 \u00b7 s i \u00b7 \u00b7 \u00b7 s n , where s i (1\u2264i \u2264n)\u2208\u03a3, \u03a3 denotes the set of items, and |\u03a3| indicates the size. A pe-170 riodic gap constraint pattern P with length m can be written as P =p 1 [a,b]p 2 \u00b7 \u00b7 \u00b7\n\n[a,b] p j \u00b7 \u00b7 \u00b7 [a,b]p m , where a and b are integers (0\u2264a\u2264b) that indicate the minimum and maximum gaps, respectively.\n\nDefinition 2. L=<l 1 ,l 2 \u00b7 \u00b7 \u00b7 l m > is an occurrence of pattern P in sequence S, if and only if 1\u2264l 1 <\u00b7 \u00b7 \u00b7 <l m \u2264n and a\u2264l j+1 -l j -1\u2264b, where s lj =p j (1\u2264j \u2264m and 175 1\u2264l j \u2264n). Suppose there is another occurrence L =<l 1 ,l 2 \u00b7 \u00b7 \u00b7 l m >. L and L are two nonoverlapping occurrences if and only if \u22001\u2264j \u2264m and l j =l j . The nonoverlapping support of pattern P in sequence S is represented by sup(P,S ).\n\nDefinition 3. If sup(P, S) is no less than support threshold minsup, pattern P is called a frequent pattern. We can know that sup(P,S 1 )=2\u2265minsup. Thus, if we mine the frequent pattern in S 1 , P is a frequent pattern.\n\nDefinition 4. Suppose L=<l 1 ,l 2 \u00b7 \u00b7 \u00b7 l m > is an occurrence. If minlen\u2264l m -l 1 +1\u2264 185 maxlen, then L is an occurrence that satisfies the length constraints, where minlen and maxlen are the minimum and maximum length constraints, respectively.\n\n]p m , and letters r and l. i.e. sup(P,S 1 )=sup(P ,S 1 )=2. Hence, pattern P is a redundant pattern. \n\nGiven a sequence and a pattern with gap constraints, all occurrences can be 215 represented by a Nettree [65] which is an extended tree structure with multiple roots and parents. Since the nodes with the same label can appear on a Nettree for multiple times, n i j is used to represent node i in the j-th level. A path from a root to a leaf in the Nettree corresponds to an occurrence of the pattern in the sequence. The problem of calculating the support of pattern P in sequence S with 220 the nonoverlapping condition means that all Nettree nodes cannot be reused in the same level [34] . The above properties make Nettree the most suitable for representing the nonoverlapping occurrences of a pattern. In our previous work [34] , NETGAP was proposed employing Nettree, which is a complete method to calculate the nonoverlapping occurrence. However, the weakness of NETGAP 225 is the lower efficiency since NETGAP must prune the invalid nodes after obtaining a nonoverlapping occurrence. Based on the above reasons, we propose the BackTr algorithm, which is of superior efficiency. Examples 5 and 6 will illustrate the principles of NETGAP and BackTr, respectively. a Nettree can be created as shown in Fig. 2 . The first step of NETGAP is to prune the invalid nodes which are n 5 2 , n 12 1 , and n 14 1 . Then NETGAP selects the first root node and finds a root-leaf path employing the leftmost child strategy. In Fig. 2 , it is easy to obtain the first root-leaf path <n 1 1 , n 2 2 , n 4 3 , n 7 4 >, marked in yellow. The corresponding occurrence is <1,2,4,7>. Then, NETGAP 235 deletes nodes n 1 1 , n 2 2 , n 4 3 , and n 7 4 . After that, NETGAP finds the invalid nodes in the new Nettree. It is clear that there are no invalid nodes at that time.\n\nThen NETGAP obtains the second root-leaf path <n 3 1 , n 6 2 , n 10 3 , n 12 4 >, marked in red and its corresponding occurrence is <3,6,10,12>. After pruning nodes NETGAP obtains the third occurrence <7,9,13,14>, which is marked in blue.\n\nHence, NETGAP gets three nonoverlapping occurrences.\n\nExample 7. In this example, we use the same pattern and sequence as in Example 5. BackTr does not need to find and prune invalid nodes n 5 2 , n 12 1 , and n 14 1 , and gets the first occurrence <1,2,4,7>. After that, BackTr selects the 245 second root n 3 1 and finds its first child node n 5 2 , which has no child node. In that case, the algorithm backtracks to node n 3 1 and finds its second child which is node n 6 2 . Thus, BackTr will get another occurrence <3,6,10,12>. Similarly, BackTr can find the third occurrence <7,9,13,14>. After that, there is no occurrence in the rest of the Nettree. Hence, BackTr also gets the same three nonoverlapping 250 occurrences as NETGAP.\n\nFrom Examples 5 and 6, it can be concluded that the two algorithms employ different methods to find the same nonoverlapping occurrences. However, NET-GAP needs to find and prune the invalid nodes for three times, while BackTr does not need to prune these nodes, which will reduce the time complexity.\n\nBackTr is given in Algorithm 1.\n\nProof. 1 Our previous work showed that the complete algorithm should iteratively find the minimum occurrence [34] . BackTr iteratively selects the leftmost As we know, the average time complexity of the NETGAP algorithm is O(m\u00d7n\u00d7w /r /r ) [34] . Hence, BackTr outperforms NETGAP. Traditional candidate pattern generation methods include breadth-first and depth-first. In this paper, the pattern growth strategy can effectively reduce the generation of redundant patterns. An example is as follows.\n\nExample 8. In Example 2, there are nine frequent patterns with length 2: 280 {\"AA\", \"AT\", \"AC\", \"AG\", \"TC\", \"TA\", \"TG\", \"CA\", \"CG\"}. With breadthfirst or depth-first strategy, 9\u00d74=36 candidate patterns with length 3 will be generated. On the other hand, since \"TT\" is not frequent, super-patterns \"ATT\" and \"TTG\" are also not frequent according to the Apriori property and can be pruned. According to the pattern growth strategy, there are 14 can-285 didate patterns: {\"AAA\", \"AAT\", \"AAG\", \"AAC\", \"CAA\", \"CAT\", \"CAC\", \"CAG\", \"TAA\", \"TAT\", \"TAC\", \"TAG\", \"TCA\", \"TCG\"}. This example illustrates that the pattern growth strategy outperforms the breadth-first and depth-first strategies.\n\nIn this subsection, we propose three pruning strategies to find closed patterns.\n\nAlthough BackTr can reduce the time complexity to calculate the support, it is also very complex. Therefore, we propose an inheriting strategy to predict the closeness of a pattern. The unclosed patterns will be pruned before support 295 calculation using BackTr.\n\nDefinition 7. Given pattern P =p 1 p 2 \u00b7 \u00b7 \u00b7 p m , and letters l and r. If there is a right gap super-pattern Q=Pr which satisfies sup(Q)=sup(P ), then P is called a right unclosed pattern. In the same way, if there is a left gap super-pattern Theorem 3. If sub-pattern P is a left unclosed pattern in sequence S, then all its right super-patterns Q=Pr are also left unclosed patterns. Therefore, pattern Q can be safely pruned. The same strategy can be applied to the right side.\n\nProof. 3 Suppose pattern P is a left unclosed pattern, which means there is a super-pattern P =lP whose support is the same as that of pattern P, i.e. sup(P ,S )=sup(P,S ). We will show that pattern Q=Pr has a super-pattern Q =lQ=lPr whose support is the same as that of pattern Q, i.e. sup(Q ,S )=sup(Q,S ).\n\nSuppose <l 1 ,l 2 \u00b7 \u00b7 \u00b7 l m ,l r > is an occurrence of pattern Q. <l 1 ,l 2 \u00b7 \u00b7 \u00b7 l m > is an 320 occurrence of pattern P. Since P is a left unclosed pattern, i.e. sup(lP,S )= sup(P,S ), we know that <l l ,l 1 ,l 2 \u00b7 \u00b7 \u00b7 l m > is an occurrence of pattern lP. Therefore, <l l ,l 1 ,l 2 \u00b7 \u00b7 \u00b7 l m ,l r > is an occurrence of pattern lP r. Thus, sup(Q ,S )=sup(Q,S ).\n\nHence, pattern Q is also a left unclosed pattern.\n\nIt should be noticed that only the unclosed property can be inherited not 325 the closed property.\n\nExample 10. In S 2 =AATGACTACTCAA, there are three nonoverlapping occurrences, <3>, <7>, and <10> for pattern \"T\" in S 2 , i.e. sup(\"T\",S 2 )=3.\n\nSince there are also three nonoverlapping occurrences, <3,5>, <7,8>, and <10,12> for the right gap super-pattern \"T[0,2]A\" of pattern \"T\", i.e. sup(\"T[0,2]A\",S 2 )=sup 330 (\"T\", S 2 )=3, pattern \"T\" is a right unclosed pattern. In addition, since \"T\" Proof. 4 If pattern P is a left unclosed pattern, then there is a super-pattern P =lP which satisfies sup(P,S )= sup(P ,S ). Thus, according to Definition 6, pattern P is an unclosed pattern. The same strategy can be applied to the right side.\n\nExample 11. In Example 9, pattern \"T\" is a right unclosed pattern, since there 345 exists a right gap super-pattern \"T[0,2]A\", that sup(\"T[0,2]A\",S 2 )= sup(\"T\",S 2 ) =3.\n\nIn the following subsections, we will propose two strategies to detect the closeness of the frequent patterns.\n\nTheorem 5. Let pattern Q be the pattern with the highest support of all the patterns that can be connected with pattern P. If sup(P)>sup(Q), then P is a closed pattern.\n\nProof. 5 Knowing that sup(P )>sup(Q), min(sup(P ), sup(Q)) is sup(Q). Patterns P and Q can generate super-pattern R by pattern growth. According to 355 Apriori, sup(R)\u2264min(sup(P ),sup(Q)). Thus, sup(R)\u2264sup(Q)<sup (P ). Therefore, there is no super-pattern R of P that satisfies sup(R)=sup (P ). Hence, P is a closed pattern.\n\nJournal Pre-proof Example 12. In Example 1, patterns \"AA\", \"AT\", \"AG\", and \"AC\" are the frequent patterns with length 2. It is known that, sup(\"AA\")=3 and 360 sup(\"AC\")=sup(\"AT\")=sup(\"AG\")= 2. The support of the pattern \"AA\" is greater than that of other patterns. According to Theorem 3, pattern \"AA\" is a closed pattern.\n\nTheorem 6. If P is both a left and right closed pattern, then P is a closed 365 pattern.\n\nProof. Suppose P is a left closed pattern which means that there is no superpattern lP that satisfies sup(lP ) = sup(P ). Similarly, suppose P is a right closed pattern, which means there is no super-pattern Pr that satisfies sup(P r) = sup(P ). Hence, P is a closed pattern according to Definition 6.\n\nExample 13. In Example 9, sup(\"A\",S 2 )=6, there is no left or right gap superpattern of pattern \"A\" that has the same support as pattern \"A\". Thus, pattern \"A\" is a left closed pattern and a right closed pattern. Hence, pattern \"A\" is a closed pattern.\n\nIn this subsection, we propose NetNCSP. At the beginning, NetNCSP traverses the sequence to find the frequent letters, and stores them in candidate set C. In the following procedures, three pruning strategies are applied to check the closeness of pattern P in C. In the first step, if P is an unclosed pattern according to Theorem 3, then NetNCSP will add P to temporary candidate set 380 C 1 and restart from the first step with another P in C. Otherwise, NetNCSP goes to the second step. In the second step, BackTr will calculate the nonoverlapping support of P and store the result in sup. If sup is less than minsup, NetNCSP will go to the first step with another P in C. Otherwise, NetNCSP adds P to C 1 and goes to the third step. In the third step, NetNCSP will check 385 the closeness of pattern P according to Theorems 5 and 6. If the pattern is 16 J o u r n a l P r e -p r o o f Journal Pre-proof closed, NetNCSP will add P to nonoverlapping closed pattern set C P . After that, NetNCSP will restart from the first step with another P in C. After all patterns in C being traversed, NetNCSP employs the pattern growth strategy to generate the candidate set using C 1 . NetNCSP will stop until C is empty.\n\nAll closed patterns are stored in C P .\n\nInput: sequence S, support threshold minsup, gap constraint gap, length constraint len\n\nOutput: nonoverlapping closed pattern set C P 1: Traverse S and store all frequent letters in candidate set C;\n\n2: while C <> NULL do 3: for each P in C do 4: if inheriting(P )==unclosed then if predicting(P )==closed or determining(P )==closed then Table 2 explains the benchmark datasets used in the following experiments.\n\nJ o u r n a l P r e -p r o o f algorithms which were proposed in References [33] and [34] , respectively.\n\n5. NetNCSP-nogap: To analyse the effect of gap constraint, NetNCSP-nogap is proposed to mine continuous patterns without gap.\n\nThe datasets and all algorithms can be downloaded from http://wuc.scse.\n\nhebut.edu.cn. NetNCSP-df employ the breadth-first and depth-first strategies, respectively.\n\nThe pattern growth strategy is more effective than the other two, which is consistent with the analysis in Example 7. Hence, NetNCSP outperforms\n\nNetNCSP-bf and NetNCSP-df.\n\nIn conclusion, NetNCSP has better performance than all the competitive algorithms.\n\nIn this subsection, we carry out two experiments to verify the nonoverlapping closed pattern mining ability and the performance of NetNCSP. 480 We used the DNA1 database to conduct the first experiment to mine patterns with pattern lengths 2 to 7. The parameters are len= [1, 1000] , gap=[0,100], and In conclusion, NetNCSP compresses the patterns effectively and outperforms competitive algorithms.\n\nRecently, a severe respiratory syndrome named COVID-19 spreads around 540 the world, and over 300,000 people worldwide have been identified with the disease. COVID-19 is caused by the SARS-CoV-2 virus [66] , which is reported to be closely related to a group of SARS-like coronaviruses (of 89.1% nucleotide similarity).\n\nIn this subsection, we use the proposed algorithm to study the similarities 545 between the two viruses. NetNCSP is employed to mine closed frequent patterns from SARS-CoV-2 and SARS viruses. We set the parameters with len = The comparison of closed pattern number is reported in Fig. 12 .\n\nThe results report the following observations. When the pattern length is \n\nIn this paper, we tackle the problem of nonoverlapping periodic gapped closed SPM and propose an effective closed pattern mining algorithm, named\n\nNetNCSP, which has two major steps, support calculation and closeness determination. In the process of support calculation, NetNCSP adopts the BackTr algorithm with backtracking strategy to calculate the nonoverlapping support 565 of patterns in Nettree. In the process of closeness determination, NetNCSP adopts three pruning strategies, inheriting, predicting, and determining. The inheriting strategy can avoid invalid calculations on the redundant patterns.\n\nThe predicting strategy can reduce the number of candidate patterns effectively.\n\nThe determining strategy determines the closeness of the frequent patterns and In this paper, we focus on nonoverlapping closed sequential pattern mining in a long sequence. Experimental results report that NetNCSP can compress 580 the frequent patterns effectively in long sequences with a small item set, such as DNA/virus sequences. However, we notice that, NetNCSP cannot compress the frequent patterns in a short sequence with a large item set, such as a protein sequence, and NetNCSP is more suitable when the gap constraints are large.\n\nHence, generator mining and maximal pattern mining can be explored in the 585 future.\n\nJ o u r n a l P r e -p r o o f Journal Pre-proof"}
{"title": "Advanced Querying Features for Disease Surveillance Systems", "body": "In its 2007 annual report, the World Health Organization warned of the increased rate at which diseases spread in a world where 2 billion people travel by air [1]. The early detection of known and emerging illnesses is becoming more important. Automated disease surveillance systems have been in existence for over 10 years [2\u20134]. Most of these systems analyze data by syndrome and search for disease outbreaks. A syndrome in this context is defined as a group of diseases related in some fashion, such as respiratory diseases. This level of investigation is often sufficient, but a more dynamic level of control may be required to understand an emerging illness in a community.\n\nFor example, during the 2002\u20132003 Severe Acute Respiratory Syndrome (SARS) disease epidemic [5], the respiratory syndrome definition used by most automated disease surveillance systems was too broad to track SARS [6]. In this case, the users needed to create queries that looked for specific keywords in the patient chief complaint or specific combinations of ICD-9 codes [7]. A chief complaint is text entered by a triage professional in an emergency room or a clinic, based on a patient\u2019s description of their primary symptoms. Today\u2019s public health departments must deal with a multitude of data coming from a variety of sources. For example, Electronic Medical Record (EMR) data include sources such as radiology, laboratory, and pharmacy data. A more sophisticated querying tool is needed to assist investigators with creating inquiries across multiple data sources [8\u201310].\n\nCurrently, there are surveillance systems, such as the Electronic Surveillance System for the Early Notification of Community-based Epidemics (ESSENCE) [11], which provide limited dynamic querying capability. However, we wanted to design a flexible and simple graphical user interface (GUI) for this and other types of surveillance systems. Our prototype system, the Advanced Querying Tool (AQT), allows the investigators to handle complex cases where one can incorporate any data elements available in a disease surveillance system, then mix and match these data elements in order to define valid queries. Hence, this system removes the need for database administrators and application developers to define pre-packaged database queries and user interfaces every time a new and innovative query is written.\n\nAs an example, investigating a potential influenza outbreak in an adult population may require respiratory syndrome queries only, while investigating a similar outbreak in children under 4 years old may involve queries in both gastrointestinal and respiratory syndromes (Figure 1).\n\nTable 1 provides examples of how a dynamic query tool exploits combinations of data elements available to disease surveillance systems. Most automated disease surveillance systems have a fixed number of predefined syndromes. These applications severely limit the surveillance system value for diseases that fall outside of its broad syndrome categories. The background noise level rises when all the chief complaints that potentially fall into a syndrome category are included, which in turn requires many more positive cases to identify an abnormal condition. Merely adding sub-syndrome categories, that are more granular than syndromes and cover a broader range of conditions than typical syndromic surveillance like injures and chronic disease [12], provides the users with a more comprehensive means to filter the analysis window. If a disease surveillance system has 400 sub-syndromes, then taken singly the user has 400 additional choices; by combining two or three sub-syndromes, the analysis options are magnified to over ten million choices. Of course not all of these options are sensible, so the actual number of options is somewhat less. Even greater analytic flexibility is provided through the use of data elements contained within electronic medical records. The capability to select a combination of a microbiology laboratory result, radiology result, and ICD-9 code provides for a powerful tool that enables the public health community to rapidly identify specific high risk patients.\n\nThe following objectives summarize the design features of the AQT:\n\nThe tool\u2019s interface will help generate queries that can process any kind of data regardless of its source (e.g., emergency room visit, office visit, pharmacy, and laboratory). Unlike fixed-form query interfaces, AQT will not restrict users in what they can query. Instead, the user will be able to formulate ad-hoc queries across assorted data sources without the need to understand the underlying data models and the query languages associated with different systems. In addition, using this tool should save investigators\u2019 valuable time in obtaining the query results. Currently, if the surveillance system cannot generate the desired queries, the application developers and/or database administrators may have to create new interfaces or functionalities. The AQT, however, empowers the users to move forward with their research without waiting for developer or administrator modifications to the surveillance systems.\n\nThe interface will accommodate users with different levels of experience in creating complex and valid queries. The process will be natural and follow the same patterns that one uses to express a mathematical equation. At the same time, it will give the more experienced users, who are familiar with the data elements, the freedom to define complex queries by sidestepping the guiding tools. The advanced users will have the ability to type in their queries and the tool will validate them and provide feedback on possible syntax errors.\n\nThe interface will allow users to save and share queries with other public health professionals, even in different jurisdictions. After defining a complex query the user has the ability to store the query for future investigations. One should be able to execute the stored query repeatedly in the future, include it as a segment of a bigger query, or customize and execute it. These saved queries can then be shared as part of collaborative efforts among users in different departments and jurisdictions. AQT will provide an interface for disease surveillance systems to store, retrieve, and share queries. These capabilities are especially valuable for users employing a case definition for following a disease outbreak. A case definition is a set of symptoms, signs, etc., by which public health professionals define those patients considered to be directly a part of the disease outbreak.\n\nFinally, the tool should be self-contained and generic. This allows most web-based disease surveillance systems to incorporate the AQT into their systems.\n\nThe entire functionality of the tool is placed within a single web page (Figure 2).\n\nThe screen in Figure 2 is divided into 5 major sections. Starting at the top, the user can filter the data by picking the data source from a dropdown list, start and end date. The surveillance system should supply this list of data sources to the AQT. The next area below is the Message Area where the GUI communicates with the user. Any information, warnings, or error messages are displayed in this section. The next area, the query section, contains the query expression. The users can either directly type the query expression or use the tool to generate the query expression and paste it in this area. Alternatively, they can use a combination of the two methods by typing part of the expression and pasting the rest using the query builder. The query section is followed by the query builder section where the tool provides list boxes, buttons, etc., to direct the user through the process of generating the query expression. The bottom section is where an action on the query is performed. Users can validate the expression\u2019s syntax, save the query for their own future use, save it to be shared with others in the user community, clear the query expression and start over, or simply execute the query and get the results.\n\nAs mentioned earlier, the capability to generate queries on data from a variety of sources is one of the objectives of the AQT. Each data source has its own distinctive set of data elements. The interface has to provide a list of data elements pertaining to the chosen data source. For example, the data might represent different geographic regions from one data source to the other. That is, one source might have data identified by zip codes while another source uses some other type of defined region such as hospitals, pharmacies, and schools. Another area where data sources can be different is in medical groupings. For example, office visits often use ICD-9 codes [7], while emergency departments use patient chief complaints. The interface is designed to distinguish valid data elements for each data source and populate the data element list box accordingly.\n\nAfter selecting a data source the tool populates a list box with a set of associated data elements for the data source. The list box is divided into three major areas:\n\nFigure 3 shows how the medical grouping systems differ for Emergency Room (right) and over the counter (left) data sources.\n\nAs mentioned earlier, a main objective of the AQT is to provide an interface that caters to both novice and experienced users. The experienced users simply type the query, while beginners and those who are more comfortable with a guided interface can use list boxes and buttons to generate the queries. In fact, one can type part of the query and use the tool to generate the rest of the query (Figure 4). When a user types a query directly, it is assumed that the user knows the syntax and valid data elements pertaining to the data source, though the tool does check the syntax and provide feedback.\n\nBecause we want the users to define and build their query as if they were writing a logical expression for a mathematical computation, the syntax is simple and close to the \u201cwhere\u201d clause of a Structure Query Language (SQL) statement. However, one does not need to know SQL to write the expressions. A query consists of one or more simple expressions joined by \u201cAND\u201d and/or \u201cOR,\u201d negated by \u201cNOT,\u201d and grouped by parentheses. A simple expression is enclosed within square brackets ([]) and defined by a variable, a logical operator, and a value. For example, if an investigator is searching for reported fever cases within a specified zip code, the query then consists of two simple expressions; one which searches for the specified zip code and the other which checks the fever syndrome. The final query may look like the expression below:\n\nIf the investigators want to narrow the search into a certain age group they can type or use the tool to add AND [AGE = \u201c0-4\u201d] to the above expression. Hence, the users can add more conditions without worrying about the underlying data model.\n\nThe most complex part of the syntax occurs when searching for values that contain, start with, or end with a set of characters (Figure 5). In this case, the syntax uses \u201c*\u201d as the wildcard character. For example, a user would type [chief-complaints = \u201c*head*\u201d] in the query box if he/she is looking for all the records of chief-complaints that include the word \u201chead.\u201d Similarly, if a user types [chief-complaints = \u201chead*\u201d] or generates it using the tool (selects the Starts With from the operator list box and types head in the text field), the resulting query would search for all the records where the chief-complaints field begins with the word \u201chead.\u201d\n\nThe procedure for generating expressions follows the same pattern a person would use to create a logical expression. The interface will provide a natural flow to help the users to create an expression as if they are typing it. They may start with selecting a data element or variable such as \u2018SEX\u2019, then a logical operator like \u2018=\u2019, and finally a value like \u2018MALE\u2019 or \u2018FEMALE\u2019. The user can add \u2018AND\u2019 or \u2018OR\u2019 and create the next expression using this same process.\n\nThe user can interject expressions in the middle of a query, remove parts of the query, or undo the last change made to the query. As changes are being made, the tool validates the entire query in the background and provides instant feedback. This method of constructing queries is more intuitive to the users than that of creating all the individual expressions first and then joining them together.\n\nOnce the data source is selected, a list of core data elements is provided in a list box. From the list box the user can select a data element. Based on the type of the data element, a list of valid logical operators for that data element is placed in another list box. Figure 6 shows the list of valid operators for text fields.\n\nIn cases such as zip code and syndrome, \u2018=\u2019 and \u2018<>\u2019 operators are also valid. For age the operators \u2018>\u2019, \u2018<\u2019, \u2018<=\u2019, and \u2018>=\u2019 are added to the list. Once the user selects a data element, a list of valid values pertaining to the data element is listed in yet another list box. The user can select one or more of these values, and if more than one value is selected the user can choose to group these values using \u2018AND\u2019 or \u2018OR\u2019. Note that the AQT generates the expression in a left to right progression in the same manner as one typing the expression (Figure 7).\n\nThe next step is to add this expression to the query. By clicking on the \u201cAdd Expression\u201d button, the expression is pasted at the cursor location in the query area. One can add more expressions to this query by clicking AND or OR buttons and following the same process (Figure 8).\n\nThe AQT helps users quickly identify limits for variables with large sets of values. Because data elements such as zip codes and ICD-9 codes have a lot of values for dropdown lists, finding a particular value in these list boxes is very cumbersome. The tool provides an intermediate step for filtering these options into a more manageable list (Figure 9). For example, if the investigators are interested in data from certain zip codes in a state, they can reduce the options by typing the first two digits of the zip code and thereby filtering the list.\n\nThe tool will generate valid expressions and provide a mechanism to check the query expressions when a user types parts or all of them. Every time an expression is generated by the tool and the Add Expression button is clicked, the tool examines the entire query expression, checking it against the syntax rules. Before saving or executing the expression the AQT automatically checks the syntax and if it detects any syntax errors it will provide meaningful error messages in the message area (Figure 10). Additionally, at any point the user can click on the validate button and check the syntax.\n\nFrequently, investigators want to execute a query over time, run the same query with different values, or use the query inside more complex queries. Similarly as all the other data elements (zip code, syndrome, region, etc.), the permanent storage and retrieval of queries (File system, database, or any other mechanism) are the responsibility of the disease surveillance system. The AQT is merely an interface to assist the investigators with their research by hiding the complexity and inner workings of the underlying data model.\n\nOnce the users define the desired query they can click on [Save Public Expression] or [Save Private Expression] buttons. If the query is valid, the screen provides an area to enter a unique name for the query (Figure 11).\n\nIf the query is successfully validated the AQT passes the name and query expression to the surveillance system. It is the surveillance system\u2019s responsibility to confirm that the query\u2019s name is unique and provide feedback to the AQT the success or failure of the save operation. Based on the feedback received the AQT provides an appropriate message in the message area.\n\nIn a collaborative environment users would like to share their findings and queries with others. Providing the capability to save and share the queries for collaborative use enables others in the user community to run these queries as they are or to make the modifications necessary to help with their own investigations. The AQT facilitates saving public queries by providing an interface similar to saving private queries (Figure 11). The surveillance system should implement the inner workings of the permanent storage and retrieval of public queries.\n\nThe next step is retrieving these saved queries. There are two options in the data element list box in the query builder section of the AQT: one option is for retrieving the private saved queries, and the other option is for retrieving public saved queries (Figure 12). Upon selection of either one, a list of corresponding queries will be presented to the users. This list includes the text of the query and the unique name given to that query. By clicking on the query name the saved query will be added to the expression in the Query area.\n\nAt this point users can add more conditions to the same query, such as specifying a zip code, changing the value for age, etc.\n\nThe final objective of this project is for the AQT to have the capability to be used with most web-based surveillance systems. One can think of the AQT as a widget, or an add-on with some defined interfaces. The back end can be implemented in a variety of popular technologies such as .NET, Java Servlet, or any other server technology as long as it can communicate via an http protocol. The surveillance system has to provide the interfaces that supply values for the different parts of the screen, and the functionality to parse the final query text and run it against the underlying database.\n\nMaking the tool adaptable to many web-based systems requires the AQT to contain all the processing dynamically, including validating the query syntax and changing the contents of the list boxes. In a web-based environment, this means using browser components such as HTML, Cascading Style Sheets (CSS) [13], JavaScript, and the Document Object Model (DOM) [14] to implement application logic. In developing AQT, we utilized HTML, JavaScript, and AJAX (Asynchronous JavaScript and XML) and placed all the processing on the local machine to avoid any server dependency.\n\nWe used JavaScript to apply validation, data handling, and screen processing on the browser side, and AJAX for communicating with server applications. AJAX is used for creating interactive web applications and is a cross-platform technique usable on many different operating systems, computer architectures, and web browsers, because it is based on open standards such as JavaScript and XML. The intent of this technique is to make web pages more responsive by exchanging small amounts of data with the server behind the scenes, so that the entire web page does not have to be reloaded each time the user requests a change. This feature increases the web page\u2019s interactivity, speed, functionality, and usability. AJAX is asynchronous in that loading does not interfere with normal page loading.\n\nThe AQT uses AJAX calls to obtain required data for populating the different list boxes on the screen. For example, when the user selects a data source the tool calls the surveillance system, passes the selected data source, gets a list of data elements from the server (the surveillance system), and then populates the data element list box. The communication to the server is done by an AJAX call, and the JavaScript processes the returned data and populates the list.\n\nESSENCE has been one of the early adaptors of AQT. Although the capability to create efficient custom queries for emergency room chief complaints data existed prior to the AQT, the query building process was cumbersome and not user-friendly. It was easy to make syntax errors while typing a query, and there was no mechanism to validate the logic of the query statement. Furthermore, while \u201cAND\u201d and \u201cOR\u201d and \u201cANDNOT\u201d expressions were possible, there was no method to construct complex Boolean operations with parentheses to clarify the order of operations. The previous capability allowed the user to base the custom query on Data Source, Geography System, or Medical Grouping System, however, since the selections were not part of the query statement they could not be modified without returning to the pre-selection screens and re-starting the query process. Additionally, the original capability did not allow for querying of data beyond the fundamental chief complaints-level. The following screen shot shows the query options that were available with the original feature. A sample chief complaints query designed to capture Influenza-Like-Illness is shown in Figure 13.\n\nThe AQT not only contains several capabilities that were not previously available, but also provides an intuitive user-friendly interface that allows the user to build simple or highly complex queries more easily. Two new features in the AQT are parentheses, which allow the user to clarify the order of operations, and the ability to select variables such as Region, Zipcode, Hospital, Syndrome, Sub-syndrome, Chief Complaint, Age, and Sex, as part of the query statement. This allows for easy query modifications. Additionally, the AQT lets the user query data beyond the fundamental chief complaints level into a more sensitive Sub-syndrome or Syndrome level. It also allows users to develop queries that contain combinations of chief complaints, syndromes, and sub-syndromes into one query. The query can also contain combinations of different geographies such as zipcodes and regions. This capability is not available without AQT.\n\nDuring the query building process the AQT automatically validates the logic of query expression as it is created, and the user has the option to conduct a final validation prior to executing the query. This feature allows the user to quickly identify syntax errors and correct them before adding further complexity or executing the query. The following screen shot (Figure 14) shows the query options available within the AQT feature. A sample chief complaints query designed to capture Influenza-Like-Illness in Region_A is shown.\n\nWe believe that the AQT will provide an interface that can assist public health investigators in generating complex and detailed case definitions. The interface supports saving queries for future use and sharing queries with others in the user community. The interface is intuitive and accommodates both novice and experienced users. Finally, the AQT is a self-contained tool that can be plugged into most web-based disease surveillance systems with relative ease."}
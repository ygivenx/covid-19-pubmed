{"title": "New method for global alignment of 2 DNA sequences by the tree data structure", "body": "The decoding of different genomes, in particular the human genomes has triggered a great deal of bioinformatics research. The research of sequence similarity to a known protein sequence or DNA sequence has been an important method to provide the first clues about the function of a newly sequenced gene. The research becomes increasingly useful in the analysis of newly sequenced genes as the sequence databases, such as DNA and protein databases, continue to grow in size. There are a number of standard schemes widely used to search for homologous sequences in nucleotide and protein databases to distinguish biologically significant relationships from chance similarities (Smith and Waterman, 1981; Waterman, 1984; Pearson and Lipman, 1988; Altschul et al., 1990 Altschul et al., , 1997 Tatiana and Thomas, 1999) . The dynamic programming algorithms (Smith and Waterman, 1981; Waterman, 1984) assign scores to insertions, deletions and replacement, and compute an alignment of two sequences. These algorithms are impractical for searching large database because of their computational requirements. Rapid heuristic algorithms (Pearson and Lipman, 1988; Altschul et al., 1990 Altschul et al., , 1997 compare protein and DNA sequences much faster than the above methods. They are widely used for large database searches. However, a number of important scientific contexts involve the comparison of only two sequences and do not require a time-consuming database search. In order to meet these needs, many important tools for large database searches (Tatiana and Thomas, 1999 ; http://www.ebi.ac.uk/Tools/emboss/align/ index.html; http://blast.ncbi.nlm.nih.gov/bl2seq/wblast2.cgi) are further developed to employ global alignment of 2 protein and nucleotide sequences. These methods can provide the global profile of similarity degree. Recently, many graphical methods have also been used to examine the global similarities/dissimilarities among the coding sequences of different species Qi, 2007, 2009; Qi and Fan, 2007; Yao et al., 2006 Yao et al., , 2008a Randi\u0107 et al., 2003a, b) . Because of the advantages in visualization, graphical methods have become a powerful bioinformatics tool for the analysis of complicated biological systems, such as enzyme-catalyzed system (Chou et al., 1979; Chou, 1980; Forsen, 1980, 1981; Chou and Liu, 1981; Myers and Palmer, 1985; Zhou and Deng, 1984; Chou, 1989 Chou, , 1990 Kuzmic et al., 1992; Andraos, 2008) , protein folding kinetics (Chou, 1990 (Chou, , 1993 , condon usage (Chou and Zhang, 1992; Zhang and Chou, 1994) , HIV reverse transcriptase inhibition mechanisms (see Althaus et al., 1993a, b , c, as well as a review article ), base frequency distribution in the anti-sense strands (Chou et al., 1996) and classifying organisms (Sorimachi and Okayasu, 2008; Okayasu and Sorimachi, 2009; . Recently, the images of cellular automata were used to represent biological sequences , predict protein subcellular location (Xiao et al., 2006a) , investigate HBV virus gene missense mutation (Xiao et al., 2005b) and HBV viral infections , predicting protein structural classes (Xiao et al., 2008) and G-protein-coupled receptor functional classes (Xiao et al., 2009 ), as well as analyze the fingerprint of SARS coronavirus (Wang et al., 2005; Gao et al., 2006) .\n\nIn this paper, we suggest a heuristic approach to align a pair of DNA sequences with the tree data structure. Some graphical descriptions are also used to intuitively explain the scheme. The method consists of three parts: (i) simple alignment algorithm, (ii) extension algorithm for largest common substring, (iii) graphical simple alignment tree (GSA tree). Here, we firstly obtain a 2-dimension (2D) graphical curve by graphical representation of scores of DNA sequences. A good simple alignment of the DNA sequences is generated when the score of the scoring curve reaches its peak value. The 2D graphical curve can intuitively show the global change of simple alignment scores based on scoring matrix. Then the largest common substrings of the good simple alignment are found out. Because of the limit of the initial alignment reaching peak score, the largest common substrings of original two sequences may be split by the largest common substrings of the good simple alignment. In order to protect these common substrings from being split, an extension algorithm for the largest common substring is suggested. Then all largest common substrings are found out when the initial alignment reaches peak score. The process is repeatedly done until GSA tree comes into being. The tree can facilitate solving the problem for global alignment of 2 DNA sequences. At last, we give several practical examples to illustrate the utility and practicality of the approach.\n\n2. Simple alignment algorithm and graphical representation of scores of DNA sequences based on scoring matrix\n\nIn bioinformatics, scoring matrix is also called as substitution matrix. As for protein sequences, the matrix is often based on observed substitution rates, derived from the substitution frequencies seen in multiple alignments of sequences. Every possible identity and substitution is assigned a score based on the observed frequencies in alignments of related proteins. Similarly, every possible identity and substitution in alignments of related DNA sequences is also assigned a score. However, the scoring matrix in alignment of DNA sequences is relatively simple and intuitional. Table 1 is a scoring matrix. An identity in scoring matrix is assigned a positive score R \u00f0R 4 0\u00de. A substitution is assigned a positive score S \u00f0S 40\u00de. But the score S must be subtracted from the total score of an alignment. For example, an alignment of two short DNA sequences ATGGTGCAACTGACT and ATGGTGCACTTGACT is the following:\n\nThe score of alignment should be 13R\u00c02S.\n\nAnother important problem for alignment is the treatment of gaps, i.e., spaces inserted to optimize the alignment score. A 'gap open' penalty is one that is the cost for the first space of each gap spaces. A 'gap extension' penalty is one that is the cost for one of each gap spaces except for the first space. Typically, the cost of extending a gap is set to be 5-10 times lower than the cost for opening a gap (http:// www.ebi.ac.uk/Tools/emboss/align/index.html). There is one way to compute a penalty for a gap of n positions: gap opening penalty + \u00f0n\u00c01\u00de \u00c3 gap extension penalty. Now, let parameter a be gap opening penalty and parameter b be gap extension penalty. And let parameter k be n\u00c01. Then we have the scoring equation: R 0 \u00c3 R\u00c0S 0 \u00c3 S\u00c0T 0 \u00c3 \u00f0a \u00fe bk\u00de, where R is the score of each match, and S is the score of each mismatch and a \u00fe bk is the score of each gap. The parameters R 0 , S 0 and T 0 denote the total amount of matches, the total amount of mismatches and the total amount of gaps, respectively.\n\n2.2. Simple alignment algorithm and graphical representation of scores of DNA sequences based on scoring matrix\n\nThere are two primary DNA sequences: G 1 (g 1 g 2 \u00c1 \u00c1 \u00c1 g M ) and G 2 (g 1 g 2 \u00c1 \u00c1 \u00c1 g N ), where M and N denote the length of G 1 and G 2 , respectively. Fig. 1 shows the building steps of all possible simple alignments without spaces within G 1 and G 2 . The gap formed by spaces lies in the hanging ends of the overlap.\n\nStep 1 of Fig. 1 gives the initial alignment that the last base of G 1 overlaps the first base of G 2 . Then every time G 1 moves one base position along the direction of G 2 .\n\nStep M \u00fe N\u00c01 of Fig. 1 gives the last alignment that the first base of G 1 overlaps the last base of G 2 . Every alignment has a score according to the scoring equation R 0 \u00c3 R\u00c0S 0 \u00c3 S\u00c0T 0 \u00c3 \u00f0a \u00fe bk\u00de. Then we can obtain a serial of dots \u00f0x; y\u00de, where x denotes index of steps and y denotes the score value corresponding to x. When one connects adjacent dots with lines, then one obtains a zigzag like curve of definite geometrical shape. In Fig. 2 we illustrate the graphical score representation of simple alignments of sequences G 1 and G 2 (G 1 , GGCCTCTGCCTAATC-ACACAGATCTAACAGGATTATTTC; G 2 , GGCCTCT GCCTTATTACAC-AAATCTTAACAGGACTATTTC). The scoring equation is R 0 \u00c3 R\u00c0S 0 \u00c3 S\u00c0T 0 \u00c3 \u00f0a \u00fe bk\u00de, where identity score R is 9, substitution score S is 1, gap opening penalty a is 15, and gap extension penalty b is 1.\n\nThe values about the parameters in the above scoring equation are chosen according to a choice of 'EMBOSS Pairwise Alignment Algorithms-needle' (http://www.ebi.ac.uk/Tools/emboss/align/ index.html). It is well known that changing the values of the parameters may change the number and length of gaps in an alignment. However, there is no analytical formula that determines the 'best' gap values to use, so that one may wish to experiment with values in order to explore more of the alignment 'space' (Tatiana and Thomas, 1999) . As for needle, one can experiment with different combinations of parameters. Here, we choose some typical values of parameters, such as R=9, S=1, a =15 and b= 1. Of course, one can choose different values by his Table 1 A usual scoring matrix.\n\nStep 1 (Initial position) N M g g g g g g g g 3 2 1 3 2 1\n\nStep 2 ( 1 G moves one base position along the right direction) experiment. In this paper, we choose these values anywhere in order to maintain consistency in the context. Fig. 2 clearly shows the graphical 'signatures' of simple alignments of sequences G 1 and G 2 . Obviously, graphical 'signatures' enable much easier visual inspection of simple alignments of DNA sequences than their representation by strings over the DNA alphabet {A, T, G, C}. A close look at Fig. 2 , one can easily find out that the score of the simple alignment reaches its peak score when the index is 39. In this paper, we call the simple alignment with peak score as a good simple alignment of sequences G 1 and G 2 .\n\nThe 2D scoring curve can intuitively show the global change of simple alignment scores based on scoring matrix. One can easily obtain the peak point by observing the curve. Of course, it is not necessary to draw the graphical scoring curve when one dose not want to observe the global change of simple alignment scores or need deal with thousands of pairs of DNA sequences. He can also determine the peak point by doing data comparison.\n\nThe above simple alignment algorithm shown in Fig. 1 is a time-consuming algorithm. Its time complexity is O\u00f0N 2 \u00de if the two aligned sequences have equal length N. Here, we provide an improved alignment process to obtain a lower time complexity. A close look at Fig. 1 shows that the beginning steps and the ending steps of the sliding process are not necessary. These unnecessary steps consume some time. Now, we need to find out the unnecessary steps to save time. Fig. 3 shows the improved process.\n\nStep (1) of Fig. 3 gives the initial alignment that the first base of G 1 overlaps the first base of G 2 . Then the sliding process is done along the left and the right, respectively. Firstly, we consider the sliding process is done along the right, as shown in step (2). Every alignment has a score S according to the scoring equation R 0 \u00c3 R\u00c0S 0 \u00c3 S\u00c0T 0 \u00c3 \u00f0a \u00fe bk\u00de. Let score S i be the score of the ith step. Let S max be the top score within all the scores (i.e., S max \u00bc maxfS 1 ; S 2 ; . . . ; S i\u00c01 g, i 41). As for every step, we still define another score S 0 i . The score S 0 i is obtained by another scoring\n\nIn the new scoring equation we assume all overlapped bases are matched each other. The sliding process is stopped when S max ZS 0 i . Obviously, the remaining steps along the right are unnecessary because all scores of the remaining steps have no chance to obtain a higher score than S max .\n\nThen we consider the sliding process is done along the left. The top score within all the scores S 0 max is maxfS max ; S 1 ; S 2 ; . . . ; S j\u00c01 g (j 41). The score S 0 j is obtained by the scoring equation\n\nThe remaining steps along the left are unnecessary. By the above sliding process the improved simple alignment algorithm can save some time. Now we discuss the time complexity. Let N and M be the length of sequences G 1 and G 2 , respectively. Let k be the total amount of the sliding steps when the sliding process is stopped. Then we can draw a conclusion that the time complexity is O\u00f0k \u00c3 M\u00de if M rN. Obviously, the more two sequences are similar, the smaller the parameter k is. Especially, the time complexity is O\u00f0N\u00de if G 1 \u00bc G 2 .\n\nBy the simple alignment algorithm a good simple alignment R of G 1 and G 2 is determined when the score of the simple \n\nwhere identity score R is 9, substitution score S is 1, gap opening penalty a is 15, and gap extension penalty b is 1.\n\n(1) Initial position g g g g g g g g g\n\n(2) Every time 1 G moves one base position along the right direction alignment reaches its peak. Let C be the largest common\n\nno largest common substring. When C \u00bc fC 1 ; C 2 ; . . . ; C m g, there are m largest common substrings, where jC 1 j \u00bc jC 2 j \u00bc \u00c1 \u00c1 \u00c1 \u00bc jC m j \u00bc k and k denotes the number of matches within a largest common substring. Here, we can see that the largest common substring C i (i \u00bc 1; 2; . . . ; m) of R devotes its maximal score to the initial alignment reaching peak score. The alignment shows the approximate overall alignment feature of G 1 and G 2 . However, some C i of the largest common substrings of R may be a part of a larger common substring than C i because of the limit of the initial alignment reaching peak score. In order to protect a larger common substring than C i from being split by C i and find out the substring, an extension algorithm for the largest common substring is suggested as the following.\n\n(1) Let K be the length of the largest common substring of G 1 and G 2 . Its value is generated when the simple alignment algorithm applies to the sequences G 1 and G 2 . (2) When k \u00bc K, none of the largest common substrings C i of R can be extended into larger common substring. The largest common substrings of R are, C 1 ; C 2 ; . . . C m . (3) When k oK, there exists at least a larger common substring than C i . There are several sub-steps to find out the larger common substrings as the following: (a) Let L L be the number of mismatches from the right end of C i\u00c01 to the left end of C i . When i \u00bc 1, L L denotes the number of mismatches from the left end of G 1 and G 2 to the left end of C 1 . Similarly, let L R be the number of mismatches from the right end of C i to the left end of C i \u00fe 1 . When i \u00bc 1, L R denotes the number of mismatches from the right end of C 1 to the right end of G 1 and G 2 . (b) When K oL L , the K mismatches are extracted from the left of C i . Otherwise, the L L mismatches are extracted from the left of C i . Similarly, when K oL R , the K mismatches are extracted from the right of C i . Otherwise, the L R mismatches are extracted from the right of C i . Then the sequences extracted from the left of C i , C i and from the right of C i are connected into two new sub-sequences S 1 i and S 2 i . (c) Now, we apply the simple alignment algorithm to S 1 i and S 2 i . If there exist a new larger common substring within S 1 i and S 2 i than C i , we will face a choice: the new larger common substring or C i . If there is an increment of sore when the new larger common substring comes into being, we will replace the original C i with the new substring also called as C i . (4) As for every C i of R, the original C i is replaced by the new largest common substring if the new substring exists. Now, we give a practical example to illustrate the above steps for a better understanding. There are two random sequences: G 1 (GCCTAGTTCCCCCA) and G 2 (GCCTCGCATCCCCCA). By the simple alignment algorithm a good simple alignment R of G 1 and G 2 is determined, where the alignment R is GCCTAGTTCCCCCA GCCTCGCATCCCCCA:\n\nThe largest common substring C of R is ''GCCT'' (C 1 ) and ''CCCC'' (C 2 ). However, the largest common substring of G 1 and G 2 is ''TCCCCCA''. Its length K is 7. Obviously, there exists at least a larger common substring than ''GCCT'' or ''CCCC''. As for ''GCCT'', the two new sub-sequences are ''GCCTAGTTC'' (S 1 1 ) and ''GCCTCGCAT'' (S 2 1 ), respectively. Because there is no increment of sore, the original common substring ''GCCT'' (C 1 ) is unchanged.\n\nAs for ''CCCC'', the two new sub-sequences are ''AGTTCCCCCA'' (S 1 2 ) and ''CGCATCCCCCA'' (S 2 2 ), respectively. Because there is an increment of sore, the original common substring ''CCCC'' (C 2 ) is replaced with the new largest common substring ''TCCCCCA''.\n\nIn sum, the extension algorithm for largest common substring protects a larger common substring than C i from being split by C i . Now, we let U denote the substrings spaced by C, where\n\n. . . ; U n g. Then the strings G 1 and G 2 are aligned into two types of substrings: (i) The largest common substrings C with continuous matches: G 1 \u00bdi \u00bc G 2 \u00bdi (of course, a single match is also permitted) and (ii) The substrings U with continuous mismatches: G 1 \u00bdi a G 2 \u00bdi and both without spaces. Obviously, a good simple alignment R of G 1 and G 2 is alternately organized by C and U (e.g.\n\nHere, the superscript of C or U denotes the level of sub-alignment. The superscript ''1'' denotes the first level. And the subscript denotes the index of substrings in the current sub-alignment. The alignment R is the result of the first level sub-alignment).\n\nIn order to expressly explain the above parameters, we give a practical example. There are two random sequences: G 1 (GCCTAGTTCCCCCA) and G 2 (GCCTCGCATCCCCCA). The G 1 \u00bdi and G 2 \u00bdi denote the base of G 1 and G 2 , respectively. They become a match when G 1 \u00bdi \u00bc G 2 \u00bdi. By the simple alignment algorithm a good simple alignment R of G 1 and G 2 is determined, where the alignment R is GCCTAGTTCCCCCA GCCTCGCATCCCCCA:\n\nAnd by the extension algorithm the largest common substring C of R is ''GCCT'' and ''TCCCCCA''. Then G 1 and G 2 are organized by C into three substrings: C 1 1 is ''GCCT'', U 1 2 is ''AGT'' and ''CGCA'', C 1 3 is ''TCCCCCA''.\n\nGiven sequences G 1 and G 2 , a graphical simple alignment (GSA) tree is built up by the aforesaid simple alignment algorithm and extension algorithm for largest common substring. In the following, we will show how to use the algorithms to construct a GSA tree of G 1 and G 2 .\n\nLet R be a good simple alignment of G 1 and G 2 . Let C 1 i and U 1 j be the largest common substring of R and be the substring spaced by C 1 i , respectively. We can see that the largest common substring C 1 i of R devotes its maximal score to the global alignment. However, the U 1 j of R may provide a increment of the score to the global alignment if given appropriate gaps within U 1 j , though the scores of these U 1 j are low in the first level sub-alignment. In order to explore the appropriate gaps in U 1 j , we give the following several operation steps.\n\n(1) Compute the scores of all simple alignments of U 1 j by the simple alignment algorithm. A good simple alignment R 1 j of U 1 j is generated when its score reaches its peak.\n\n(2) If there is a increment of the score due to appropriate gaps within U 1 j , U 1 j can be further divided into the second level subalignment. When and how to add the gaps in the sequences? Now, let C 2 i be the largest common substrings of R 1 j , where\n\n. . . ; C 2 i \u00fe m g. Then there are two sub-steps as the following: (a) If C 2 i \u00bc fC 2 i \u00fe 1 ; C 2 i \u00fe 2 ; . . . ; C 2 i \u00fe m g, there are m largest common substrings. Then U 1 j can be further divided into the second level sub-alignment by C 2 i . Let U 2 j be the substrings spaced\n\n. . . ; U 2 j \u00fe n g. Then every substring C 2 i \u00fe k (k \u00bc 1; 2; . . . ; m) of C 2 i becomes a leaf node in GSA tree. There are no gaps within them. As for every substring U 2 j \u00fe k (k \u00bc 1; 2; . . . ; n) of U 2 j , the operation flow goes back to the step (1). And the level of sub-alignment enters the next.\n\nThen U 1 j can not be further broken down. The good simple alignment R 1 j of U 1 j becomes a leaf node in GSA tree. The two sequences of R 1 j might be entirely overlapping, or partially overlapping, or one sequence might be aligned entirely internally to the other. When the two sequences of R 1 j are entirely overlapping, there are no gaps within R 1 j . Otherwise, the hanging ends of the overlap come into being the gaps of R 1 j . The relative position of these gaps is fixed, and becomes the gaps within the final global alignment.\n\nWe repeatedly do the above steps until all U in the last level sub-alignment cannot be further decomposed by the simple alignment algorithm and the extension algorithm. Then we can obtain a graphical simple alignment tree for strings G 1 and G 2 , consisting of a series of substrings. The Fig. 4 illustrates an example of GSA tree.\n\nWe can obtain a global alignment of strings G 1 and G 2 when their GSA tree is generated. In the following, we will show how to use GSA tree to generate a global alignment. Observing the GSA tree (e.g. Fig. 4) , we can see that there are two types of nodes: inner nodes and leaf nodes. The inner nodes consist of substrings U that can be aligned to more substrings. The leaf nodes include substrings C and U, where U cannot be further aligned by the GSA tree method. The global alignment of strings G 1 and G 2 should be composed of all leaf nodes. In order to obtain the global alignment, the GSA tree is traversed by post-order traversal of tree. Then all inner nodes are deleted from the result of post-order traversal. We will achieve the global alignment of strings G 1 and G 2 . For example, the result of post-order traversal of Fig. 4 is\n\nThe global alignment is C 2 1 U 3 1 C 3 2 C 2 3 C 1 2 U 2 4 C 2 5 C 1 4 U 2 6 C 2 7 C 3 3 U 3 4 C 1 6 by removing all of inner nodes.\n\nIn this section, we give three examples to see the validity of GSA tree for the global alignment of 2 DNA sequences. As for every example, we compare the results by GSA tree with the results by the important heuristic approach ''EMBOSS Pairwise Alignment Algorithms-needle'' (http://www.ebi.ac.uk/Tools/ emboss/align/index.html).\n\nWe firstly apply the proposed method to the discussed 2 sequences: G 1 (GGCCTCTGCCTAATCACACAGATCTAACAGGAT-TATTTC) and G 2 (GGCC TCTGCCTTATTACACAAATCTTAACAGGAC-TATTTC). The scoring equation is R 0 \u00c3 R\u00c0S 0 \u00c3 S\u00c0T 0 \u00c3 \u00f0a \u00fe bk\u00de, where identity score R is 9, substitution score S is 1, gap opening penalty a is 15, and gap extension penalty b is 1. Of course, one may also choose other values as the parameters of the scoring equation according to practical requirement. Here, we choose the same values in order to keep the context consistency. In Fig. 2 , we have described the graphical score representation of simple alignments of sequences G 1 and G 2 . One can easily find out that the score of the simple alignment reaches its peak when index of step in Fig. 1 is 39. Then we can obtain the first level sub-alignment results according to the simple alignment algorithm and the extension algorithm. By similar rules, we can get all possible sub-alignment results. Fig. 5 shows the GSA tree to be used to align the sequences G 1 and G 2 . Table 2 lists all substrings of Fig. 5 and the max score of each pair of substrings. Then we obtain the global alignment of the sequences: C 1 1 U 4 1 C 4 2 U 4 3 C 3 2 U 4 4 C 4 5 U 4 6 C 2 2 U 3 4 C 3 5 . According to the results of Table 2 , we illustrate the global alignment results as the following:\n\nThe notation ''-'' denotes the gap within sequence. Then we apply ''needle'' program to G 1 and G 2 . The values about gap opening penalty a and gap extension penalty b are the same as the values proposed the GSA tree algorithm. The default values about identity score R and substitution score S are chosen because of no other choice. The alignment results are shown as the following:\n\nObviously, we get consistent results by two different methods. Moreover, similar results can be found out in Table 1 of Randi\u0107 et al. (2006) .\n\nThe aforesaid example about the validity examination gives rise to a question: Is it possible to use the GSA tree in order to facilitate solving less similar or longer DNA sequence alignment problem? The answer is positive. Now, we randomly give two less similar sequences: G 1 and G 2 (G 1 , GCCCTCGCGGGCAACATTTAATT-Strings 1 G and 2 G \n\nLevel 3 Fig. 4 . An example of graphical simple alignment tree (Strings G 1 and G 2 includes 6 substrings in the first level sub-alignment: U 1 1 C 1 2 U 1 3 C 1 4 U 1 5 C 1 6 . The substring U 1 1 includes 3 substrings in the second level sub-alignment: C 2 1 U 2 2 C 2 3 . The substring U 1 3 includes 2 substrings in the second level sub-alignment: U 2 4 C 2 5 . The substring U 1 5 includes 3 substrings in the second level sub-alignment: U 2 6 C 2 7 U 2 8 . The substring U 2 2 includes 2 substrings in the third level sub-alignment: U 3 1 C 3 2 . The substring U 2 8 includes 2 substrings in the third level sub-alignment: C 3 3 U 3 4 ).\n\nCACAGCCAGTTCTCTCAACAGTGATTATC; G 2 , CTGGGTCTTCAGGT-CCTTTATGCTTAACACAAATCTATCGTTA ACAGGACTATTCT). Like the above example, the scoring equation is R 0 \u00c3 R\u00c0S 0 \u00c3 S\u00c0T 0 \u00c3 \u00f0a \u00febk\u00de, where identity score R is 9, substitution score S is 1, gap existence penalty a is 15, and gap extension penalty b is 1. By GSA tree algorithm, we can get the GSA tree and all possible sub-alignment results. Fig. 6 shows the GSA tree to be used to align the sequences G 1 and G 2 . Table 3 lists all substrings in Fig. 6 and the max score of each pair of substrings. Then we obtain the global alignment of the sequences:\n\nU 4 1 C 4 2 U 4 3 C 4 4 U 4 5 C 3 2 U 3 3 C 2 2 U 4 6 C 4 7 U 4 8 C 3 5 U 3 6 C 2 4 U 2 5 C 1 2 U 3 7 C 3 8 U 3 9 C 3 10 U 3 11 C 2 7 U 4 9 C 4 10 U 4 11 C 3 13 U 3 14 C 2 9 U 2 10 C 1 4 U 1 5 : According to Table 3 , we illustrate the global alignment results as the following:\n\nAccording to the results, we can obtain some conclusions of the global alignment between the sequences G 1 and G 2 : Length: 61; Identities: 31/61 (50.8%); Gaps: 14/61 (22.9%); Score: 169. Then we apply ''needle'' program to G 1 and G 2 . The alignment results are shown as the following:\n\nThen we can obtain some conclusions of the global alignment between the sequences G 1 and G 2 : Length: 64; Identities: 32/64 (50%); Gaps: 20/64 (31.2%); Score: 29.\n\nObviously, in this example we get different results by two different methods. A close look at the alignments reveals that there are two different areas (the bold areas illustrate the almost identical ones): the bases from 1 to 20 by GSA tree vs. the bases from 1 to 21 by needle, and the bases from 34 to 46 by GSA tree vs. the bases from 35 to 49 by needle. As for the first area, GSA tree obtains 7 matches by 3 gap openings and 5 gap extensions while needle gets 6 matches by 2 gap openings and 8 gap extensions. In the second area GSA tree gets 5 matches by 1 gap openings and 0 gap extensions while needle obtains 7 matches by 2 gap openings and 3 gap extensions. From the global view, GSA tree receives 31 matches by 7 gap openings and 7 gap extensions while needle gets 32 matches by 7 gap openings and 13 gap extensions. However, it is difficult for us to determine which one is the better when it comes to the best global alignment of the sequences considered. In fact, a close look at the alignments discovers that both of the methods can find out those very similar local areas, such as the bold areas of the alignments.\n\nFinally, we give the third example with two long and very similar sequences to see the validity of GSA tree for the global alignment of 2 DNA sequences. Here, we apply the proposed method to the complete coding sequence part of beta globin gene of Human (ACCESSION U01317) and Opossum (ACCESSION J03643) as shown in Table 4 . The scoring equation is R 0 \u00c3 R\u00c0S 0 \u00c3 S\u00c0T 0 \u00c3 \u00f0a \u00fe bk\u00de, where identity score R is 9, substitution score S is 1, gap existence penalty a is 15, and gap extension penalty b is 1. For simplification, we do not show the detail of GSA tree and the results of all substrings. In Fig. 7 , we illustrate the final result. The notation ''-'' denotes the gap within sequence. According to the figure, we can obtain some conclusions of the global alignment between string G 1 (the complete coding sequence of ACCESSION U01317) and string G 2 (the complete coding sequence of ACCESSION J03643): Length: 448; Identities: 328/448 (73.2%); Gaps: 8/448 (1.8%); Score: 2772. Then we apply the web tool for ''needle'' program to G 1 and G 2 . The conclusions about the global alignment is the following: Length: 448; Identities: 328/448 (73.2%); Gaps: 8/448 (1.8%); Score: 1128.0. From the global view, the two methods almost get the same statistics results except for their scores. There is only one different area: the bases from 33 to 34 by GSA tree vs. the bases from 33 to 34 by needle. In fact, the two different areas are equivalent to each other. This example shows that it is possible to use the GSA tree in order to facilitate solving long and very similar DNA sequence alignment problem.\n\nThe GSA tree algorithm is a gradual algorithm that step by step explores suitable gaps to improve the score of the alignment between 2 DNA sequences. The scheme firstly uses the simple alignment algorithm and the extension algorithm to construct a GSA tree. The substrings denoted by leaf node of GSA tree are looked on as a part of the final global alignment. Obviously, GSA tree method is a heuristic algorithm. There is no analytical formula to determine the 'best' gap values. Though GSA tree algorithm is a heuristic method, and could not always get the optimal alignment, the validity and practicality of the results can be ensured. Firstly, we discuss the influence about the initial simple alignment of GSA tree algorithm. In Section 3.2, we describe in detail the construction steps of GSA tree by the initial simple alignment. As for the overall result, the initial simple alignment is very important. It determines the extent to which the consolidated results close to optimal results. Next, we discuss the initial simple alignment and its optimized features.\n\nBy the simple alignment algorithm a good simple alignment R of sequences G 1 and G 2 is determined when the score of the simple alignment reaches its peak. Then the largest common substrings C of R is determined, where C \u00bc f [ fC 1 ; C 2 ; . . . ; C m g.\n\nWhen C \u00bc fC 1 ; C 2 ; . . . ; C m g, there are m the largest common substrings. Because of the limit of the initial alignment reaching peak score, some C i of the largest common substrings of R may be a part of a larger common substring than C i . An extension algorithm for the largest common substring is suggested to protect a larger common substring than C i from being split by C i if the larger common substring exists. Then we replace the original C i with the new larger common substring also called as C i . Once the largest common substrings C i is determined, it is looked on as a part of the overall result. Then in an optimal alignment of G 1 and G 2 (This hypothetical alignment may be obtained by an absolutely optimized algorithm), the two sequences of C i by GSA tree might be entirely overlapping in the optimal alignment, or partially overlapping, or one sequence might be entirely isolated from the other. Obviously, for the latter two cases, a great deal of gaps and mismatches may be introduced. So the substring C i is most likely to appear in the optimal alignment.\n\nThe above explanation gives some approximate analysis instead of strict mathematical reasoning, but the conclusion is reasonable from the biological point of view. As the sequences under comparison are protein coding, gaps with lengths other than multiples of three are highly unlikely, whereas the GSA tree algorithm can avoid many single or two-base gaps by the approximate approach. Unlike ''EMBOSS Pairwise Alignment Algorithms-needle (global)'' or ''-water (local)'', the proposed GSA tree algorithm is to find a balance between the global and local. The algorithm is for aligning two sequences over their entire . The graphical simple alignment tree to be used to align the sequences G 1 and G 2 (G 1 , GCCCTCGCGGGCAACATTTAATTCACAGCCAGTTCTCTCAACAG TGATTATC; G 2 , CTGGGTCTTCAGGTCCTTTATGCTTAACACAAATCTATC GTTAACAGGACTATTCT). length. The match areas with local superiority are produced in the global context. In bioinformatics, it may be reasonable to assume that in the global context the local areas with closely related sequences should be reflected because of the stability of these areas. As for two possibly related sequences, giving priority to these local areas may be a better choice. The accurate optimization Table 3 All substrings in Fig. 6 and the max score of each substring.\n\nU 4 8 \u00f0G 1 \u00de: A U 4 8 \u00f0G 2 \u00de: C \u00c0 1 U 3 12 \u00f0G 1 \u00deU 3 12 \u00f0G 2 \u00de U 4 9 \u00f0G 1 \u00de: -U 4 9 \u00f0G 2 \u00de: G \u00c0 15 C 4 10 \u00f0G 1 \u00de \u00bc C 4 10 \u00f0G 2 \u00de: T 9 U 4 11 \u00f0G 1 \u00de: C U 4 11 \u00f0G 2 \u00de: T \u00c0 1 result could not show these local features because of the global optimization. The proposed GSA tree algorithm is for aligning two sequences over their entire length. This works best with closely related sequences. If one uses GSA tree to align very distantly related sequences, it will produce a result but much of the alignment may have little or no biological significance. The three examples of 4.1 give practical proofs for the validity and practicality of the GSA tree algorithm. The Example 1 gives two very similar but very short sequences. The GSA tree achieves the same results as needle. The Example 3 gives two similar and long sequences. There is only one different area:\n\nThis example shows that giving priority to these local areas may be a better choice. The Example 2 gives two random sequences. There are two different areas in their results. A close look at the alignments discovers that both of the methods can find out those very similar local areas. The main differences between them lie in the very distantly related areas.\n\nFinally, the following analysis shows why we consider the substring C i in the only initial alignment reaching peak score. Because of the limit of the initial alignment reaching peak score, some C i of the largest common substrings of R may be a part of a larger common substring than C i . Then an extension algorithm for\n\nG 1 1 G 2 1 51 51 \n\nG 1 52 G 2 52 102 102 GG T C T A C C C T T G G A C C C A G AGGTT C T T T G A G T C C T T T GGGGA T C T G T C C A C TG T C T A C C C C T G G A C C A C C AGGT T T T T T GGGAGC T T T GGT G A T C T G T C C T C G 1 103 G 2 103 153 153 "}